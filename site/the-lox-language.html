<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>The Lox Language &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/craftinginterpreters/"><img src="image/logotype-small.png" title="Crafting Interpreters"></a>
  <div class="contents">
<!-- If there is a part, it must be a chapter within a part. -->
<h3><a href="#top">The Lox Language<small>3</small></a></h3>

<ul>
    <li><a href="#你好-lox"><small>3.1</small> 你好, Lox</a></li>
    <li><a href="#一门高级语言"><small>3.2</small> 一门高级语言</a></li>
    <li><a href="#数据类型"><small>3.3</small> 数据类型</a></li>
    <li><a href="#表达式"><small>3.4</small> 表达式</a></li>
    <li><a href="#语句"><small>3.5</small> 语句</a></li>
    <li><a href="#变量"><small>3.6</small> 变量</a></li>
    <li><a href="#控制流"><small>3.7</small> 控制流</a></li>
    <li><a href="#函数"><small>3.8</small> 函数</a></li>
    <li><a href="#类"><small>3.9</small> 类</a></li>
    <li><a href="#标准库"><small>3.10</small> 标准库</a></li>
    <li><a href="#挑战"><small>3.11</small> 挑战</a></li>
    <li><a href="#语言设计笔记：表达式和语句"><small>3.12</small> 语言设计笔记：表达式和语句</a></li>
</ul>


<div class="prev-next">
    <a href="a-map-of-the-territory.html" title="A Map of the Territory" class="left">&larr;&nbsp;Previous</a>
    <a href="welcome.html" title="Welcome">&uarr;&nbsp;Up</a>
    <a href="a-tree-walk-interpreter.html" title="A Tree-Walk Interpreter" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/craftinginterpreters/"><img src="image/logotype-small.png" title="Crafting Interpreters"></a>
<a href="a-map-of-the-territory.html" title="A Map of the Territory" class="prev">←</a>
<a href="a-tree-walk-interpreter.html" title="A Tree-Walk Interpreter" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/craftinginterpreters/"><img src="image/logotype-small.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<!-- If there is a part, it must be a chapter within a part. -->
<h3><a href="#top">The Lox Language<small>3</small></a></h3>

<ul>
    <li><a href="#你好-lox"><small>3.1</small> 你好, Lox</a></li>
    <li><a href="#一门高级语言"><small>3.2</small> 一门高级语言</a></li>
    <li><a href="#数据类型"><small>3.3</small> 数据类型</a></li>
    <li><a href="#表达式"><small>3.4</small> 表达式</a></li>
    <li><a href="#语句"><small>3.5</small> 语句</a></li>
    <li><a href="#变量"><small>3.6</small> 变量</a></li>
    <li><a href="#控制流"><small>3.7</small> 控制流</a></li>
    <li><a href="#函数"><small>3.8</small> 函数</a></li>
    <li><a href="#类"><small>3.9</small> 类</a></li>
    <li><a href="#标准库"><small>3.10</small> 标准库</a></li>
    <li><a href="#挑战"><small>3.11</small> 挑战</a></li>
    <li><a href="#语言设计笔记：表达式和语句"><small>3.12</small> 语言设计笔记：表达式和语句</a></li>
</ul>


<div class="prev-next">
    <a href="a-map-of-the-territory.html" title="A Map of the Territory" class="left">&larr;&nbsp;Previous</a>
    <a href="welcome.html" title="Welcome">&uarr;&nbsp;Up</a>
    <a href="a-tree-walk-interpreter.html" title="A Tree-Walk Interpreter" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">3</div>
  <h1>The Lox Language</h1>

<blockquote>
<p>为某个人做的事情中，有比为这个人做早餐更好的事情吗？</p>
<p><cite>安东尼·波登</cite></p>
</blockquote>
<p>我们将用本书的剩余部分来阐述Lox语言的每一个边边角角。但马上就开始写实现解释器的代码，似乎显得有点残忍。我们至少得熟悉一下我们要实现的语言的语法吧。</p>
<p>但同时，我也不想在你还没开始用文本<span name="home">编辑器</span>写Lox的实现代码时，就把Lox语言的各种细节和规范介绍一遍。所以本章将是对Lox的一个比较温和友好的介绍。很多语言的细节和边界条件将不会在本章介绍。后面我们有的是时间。</p>
<aside name="home">
<p>如果你不能自己尝试编写代码并运行，那么教程就不会很有趣。哦对了，你还没有Lox解释器，因为你还没有开始写呢！</p>
<p>没关系，先用<a href="https://github.com/confucianzuoyuan/craftinginterpreters">我的</a>。</p>
</aside>
<h2><a href="#你好-lox" name="你好-lox"><small>3&#8202;.&#8202;1</small>你好, Lox</a></h2>
<p>我们先来简单尝试一下<span name="salmon">Lox</span>：</p>
<aside name="salmon">
<p>我们现在想要尝鲜的是Lox，这是一门语言。我不知道你吃过腌制的冷熏鲑鱼没有，如果没吃过，也可以试一下。</p>
</aside>
<div class="codehilite"><pre>
<span class="c">// 你的第一个Lox程序！</span>
<span class="k">print</span> <span class="s">&quot;Hello, world!&quot;</span>;
</pre></div>
<p><code>//</code>行注释和语句末尾的分号说明了Lox的语法是C家族的成员。（&ldquo;Hello, world!&rdquo;字符串的两边没有括号是因为<code>print</code>是一个内建的语句，而不是一个库函数。）</p>
<p>我不想说<span name="c">C</span>拥有着<em>伟大的</em>语法。如果我们想要优雅的语法，那么Lox可能会采用Pascal或者Smalltalk的语法风格。如果我们想要更加简洁的语法风格，我们可能会选择Scheme那样的语法。这些语言都有各自的价值。</p>
<aside name="c">
<p>我肯定对Lox有偏爱，但我觉得Lox的语法非常的干净。C语言语法最大的问题是有关类型的。丹尼斯·里奇把这个有关类型的想法叫做“<a href="http://softwareengineering.stackexchange.com/questions/117024/why-was-the-c-syntax-for-arrays-pointers-and-functions-designed-this-way">声明反映使用</a>”，也就是说变量的声明反映了如果你想要获取基本类型的值，你需要对变量进行什么样的操作。伟大的创意，但在实践中很多变量声明非常难以理解。</p>
<p>Lox不是静态类型语言，所以我们避免了上面的这个大问题。</p>
</aside>
<p>那么类C语言的语法有什么优点呢？优点就是：<em>熟悉感</em>。因为我们已经假设过读者对我们将要用来<em>实现</em>Lox的两门语言——Java和C——很熟悉了。那么Lox的语法显然读者也会很容易上手。Lox使用和Java、C相似的语法，可以让我们少学一些语法特性。</p>
<h2><a href="#一门高级语言" name="一门高级语言"><small>3&#8202;.&#8202;2</small>一门高级语言</a></h2>
<p>写完这本书时，书的厚度超出了我所期望的厚度。但这本书还没有厚到能够容纳讲解类似于Java这样的语言的实现的厚度。为了在本书中包含Lox语言的两个实现，Lox的语法必须非常紧凑。</p>
<p>当我在想有哪些语言是小而有用的编程语言时，映入我脑海的是高级“脚本”语言，例如<span name="js">JavaScript</span>，Scheme和Lua。在这三种语言中，Lox最像JavaScript，因为类C语言的语法都像JavaScript。而Lox在作用域方面很接近Scheme。在<a href="a-bytecode-virtual-machine.html">第三部分</a>中，我们将使用C语言实现Lox解释器，实现方式大量的参考了Lua清晰而高效的实现。</p>
<aside name="js">
<p>现在JavaScript这门语言已经统治了世界，并构建了很多超大型应用。所以再叫它“小型脚本语言”已经不太合适了。在最开始，布兰登·艾奇花了<em>十天</em>就写出了第一个JS解释器并运行在了网景浏览器上，还让网页上的按钮动了起来。在那时，JS确实是一个小型脚本语言。但随着JavaScript的发展，它已经变得很庞大了。</p>
<p>大概艾奇在设计JS时花的时间太少了，所以留下了很多坑。例如变量提升，<code>this</code>的动态绑定，数组中的空洞，以及隐式类型转换。</p>
<p>我花了很多的时间在Lox上面，所以Lox比JS应该会更加干净一些。</p>
</aside>
<p>Lox和上面提到的三门语言还有两点相似之处：</p>
<h3><a href="#动态类型" name="动态类型"><small>3&#8202;.&#8202;2&#8202;.&#8202;1</small>动态类型</a></h3>
<p>Lox是动态类型语言。变量可以存储任意类型的值。一个相同的变量甚至可以在不同的时间存储不同类型的值。如果你想要在错误的类型的值上面做一些运算——例如，整型和字符串进行相除——那么这个错误将在运行时发现和报告。</p>
<p>有很多对<span name="static">静态</span>类型偏爱的理由。但因为一些实践方面的原因，我们的Lox还是选择了动态类型。一个静态类型系统需要学习大量的东西以及写大量的代码才能实现。忽略掉静态类型系统采用动态类型系统，会让我们的语言更加简单，书也会薄一些。我们在运行时才会做一些类型检查。这样我们构建解释器的速度会快一些。</p>
<aside name="static">
<p>最后，我们用来<em>实现</em>Lox解释器的两种语言——C和Java——都是静态类型语言。</p>
</aside>
<h3><a href="#自动内存管理" name="自动内存管理"><small>3&#8202;.&#8202;2&#8202;.&#8202;2</small>自动内存管理</a></h3>
<p>高级语言存在的一个目的就是消除容易出错和操作底层的繁琐工作，尤其是还有什么工作比手动管理内存的分配和释放更加烦人的事情呢？没有人会早晨起床然后互相打招呼说：“我已经迫不及待的想为我今天分配的每一块内存调用<code>free()</code>函数了！”</p>
<p>有两种主要的<span name="gc">技术</span>用来管理内存：<strong>引用计数（reference counting）<strong>和</strong>跟踪垃圾回收（tracing garbage collection）</strong>（通常简称为<strong>垃圾收集（garbage collection）<strong>或者</strong>GC</strong>）。引用计数器更加容易实现——我想这就是Perl、PHP和Python最开始都使用引用计数的原因。但是随着语言的发展，引用计数的局限性越来越大。所以这些语言到最后都添加了一个完整的跟踪GC实现，来管理对象的生命周期。</p>
<aside name="gc">
<p>在实践中，引用计数和跟踪这两种技术更像是连续谱上的两个点，而不是完全相反的两个极端。大部分引用计数系统最终都会使用一些跟踪技术来管理对象的生命周期。而分代垃圾回收机制更像是一种在引用计数搞不定的情况下才会使用的技术。</p>
<p>有关这方面的技术, 可以参考 &ldquo;<a href="https://researcher.watson.ibm.com/researcher/files/us-bacon/Bacon04Unified.pdf">A Unified Theory of Garbage Collection</a>&rdquo; (PDF).</p>
</aside>
<p>跟踪垃圾回收技术有着非常恐怖的名声。因为，这种技术会在内存这个级别上工作。调试GC可能会让你做噩梦，梦里都是16进制的转储（dump）信息。但是，请记住，本书就是来消除魔法并杀死怪兽的，所以我们将编写自己的垃圾回收器。你会发现GC算法很简单，而且实现起来很有趣。</p>
<h2><a href="#数据类型" name="数据类型"><small>3&#8202;.&#8202;3</small>数据类型</a></h2>
<p>在Lox语言这个小小的宇宙中，构建起整个宇宙的原子其实就是内建的数据类型。下面是一些数据类型：</p>
<ul>
<li>
<p><strong><span name="bool">布尔类型（Booleans）</span>.</strong> 没有逻辑我们无法编程，而没有布尔值，那么连逻辑都将不存在。“真（true）”和“假（false）”就是软件的阴和阳。不像很多古老的语言，使用一些已经存在的类型来表示真和假，Lox专门实现了布尔类型。我们可能实现的较为粗糙，但我们也不是<em>野蛮人</em>。</p>
<aside name="bool">
<p>在Lox中，布尔值是唯一一种用人名来命名的数据类型。他就是George Boole，这就是为了&ldquo;Boolean&rdquo;首字母大写的原因。他死于1864年，过了一个世纪，他所发明的布尔代数才真正变成了数字计算机。我很好奇如果他看到Java代码里有着成千上万他的名字是一种什么感觉。</p>
</aside>
<p>布尔类型有两个值，true和false。</p>
<div class="codehilite"><pre>
<span class="k">true</span>;  <span class="c">// Not false.</span>
<span class="k">false</span>; <span class="c">// Not *not* false.</span>
</pre></div>
</li>
<li>
<p><strong>数（Numbers）.</strong> Lox只有一种数：双精度浮点数。因为浮点数还可以表示一个很大范围的整数。所以只有一种数会让实现更加简单。</p>
<p>功能齐全的编程语言有着很多数的语法——十六进制，科学计数法，八进制，以及各种有趣的东西。我们这里只有整数和十进制数。</p>
<div class="codehilite"><pre>
<span class="n">1234</span>;  <span class="c">// An integer.</span>
<span class="n">12.34</span>; <span class="c">// A decimal number.</span>
</pre></div>
</li>
<li>
<p><strong>字符串（Strings）.</strong> 我们已经在第一个例子中看到了一个字符串字面量。像大多数编程语言一样，字符串被包含在双引号当中。</p>
<div class="codehilite"><pre>
<span class="s">&quot;I am a string&quot;</span>;
<span class="s">&quot;&quot;</span>;    <span class="c">// The empty string.</span>
<span class="s">&quot;123&quot;</span>; <span class="c">// This is a string, not a number.</span>
</pre></div>
<p>正如我们在实现字符串这一特性时所能看到的，有很多的复杂性隐藏在<span name="char">一堆字符</span>人畜无害的表面之下。</p>
<aside name="char">
<p>即使是“字符”这个词也很具有欺骗性。字符是ASCII？还是Unicode？是代码点还是“字素簇”？字符是如何编码的？每个字符的大小是固定的还是可变的？</p>
</aside></li>
<li>
<p><strong>Nil.</strong> 最后一种内建类型是Nil，我们并没有邀请它参加聚会，但它总是自己出现。Nil表示“没有值”。在很多语言中我们使用单词“null”来表示没有值。在Lox中，我们使用<code>nil</code>这个词。（当我们实现这个类型的时候，我们将会对比一下Lox的<code>nil</code>和Java、C语言中的<code>null</code>。）</p>
<p>有很多种理由不在一门语言中引入null值，因为空指针异常（null pointer errors）在工业界造成了很大的损失。如果我们实现的是一门静态类型语言，那么不引入null值是值得的。但在一门动态类型语言中，消除null比引入null更加烦人。</p>
</li>
</ul>
<h2><a href="#表达式" name="表达式"><small>3&#8202;.&#8202;4</small>表达式</a></h2>
<p>如果说内建数据类型和它们的字面量是原子的话，那么<strong>表达式</strong>就是分子了。大部分表达式大家应该都很熟悉。</p>
<h3><a href="#算术表达式" name="算术表达式"><small>3&#8202;.&#8202;4&#8202;.&#8202;1</small>算术表达式</a></h3>
<p>Lox的基本算术表达式和其他类C语言一样：</p>
<div class="codehilite"><pre>
<span class="i">add</span> + <span class="i">me</span>;
<span class="i">subtract</span> - <span class="i">me</span>;
<span class="i">multiply</span> * <span class="i">me</span>;
<span class="i">divide</span> / <span class="i">me</span>;
</pre></div>
<p>操作符两边的子表达式叫做<strong>操作数（operands）</strong>。因为以上操作符有<em>两个</em>操作数，所以这些操作符一般叫做**二元（binary）<strong>操作符。（这里的binary和二进制0-1的binary没关系。）因为这些操作符是<span name="fixity">固定</span><em>在</em>两个操作数中间的，所以它们又叫</strong>中缀（infix）<strong>操作符（和出现在操作数前面的</strong>前缀（prefix）<strong>操作符以及出现在操作数后面的</strong>后缀（postfix）**操作符相对应）。</p>
<aside name="fixity">
<p>有些操作符会有多于两个的操作数，而操作符会在这些操作数之间放置。只有一个大量使用的这种操作符，就是“条件操作符”或者叫做“三元操作符”（C中这么叫）：</p>
<div class="codehilite"><pre>
<span class="i">condition</span> ? <span class="i">thenArm</span> : <span class="i">elseArm</span>;
</pre></div>
<p>有些人叫这种操作符为<strong>mixfix</strong>操作符。有很少的一部分编程语言（Haskell、OCaml）允许你定义自己的操作符，以及控制这些操作符的摆放位置——也就是它们的“fixity”。</p>
</aside>
<p>有一个算术操作符既是中缀操作符也是前缀操作符。那就是<code>-</code>，当<code>-</code>操作符放在数的前面是，表示负号。</p>
<div class="codehilite"><pre>
-<span class="i">negateMe</span>;
</pre></div>
<p>以上所有这些操作符都是作用在数上面的，所以不能使用这些操作符来操作其他类型。<code>+</code>操作符是一个例外——你可以使用<code>+</code>来拼接两个字符串。</p>
<h3><a href="#比较和判断相等表达式" name="比较和判断相等表达式"><small>3&#8202;.&#8202;4&#8202;.&#8202;2</small>比较和判断相等表达式</a></h3>
<p>让我们继续，我们有一些比较操作符会返回布尔类型的结果。</p>
<div class="codehilite"><pre>
<span class="i">less</span> &lt; <span class="i">than</span>;
<span class="i">lessThan</span> &lt;= <span class="i">orEqual</span>;
<span class="i">greater</span> &gt; <span class="i">than</span>;
<span class="i">greaterThan</span> &gt;= <span class="i">orEqual</span>;
</pre></div>
<p>我们可以测试任意类型的两个值是否相等。</p>
<div class="codehilite"><pre>
<span class="n">1</span> == <span class="n">2</span>;         <span class="c">// false.</span>
<span class="s">&quot;cat&quot;</span> != <span class="s">&quot;dog&quot;</span>; <span class="c">// true.</span>
</pre></div>
<p>甚至比较不同的类型的两个值。</p>
<div class="codehilite"><pre>
<span class="n">314</span> == <span class="s">&quot;pi&quot;</span>; <span class="c">// false.</span>
</pre></div>
<p>当然，不同类型的两个值<em>永远</em>不会相等。</p>
<div class="codehilite"><pre>
<span class="n">123</span> == <span class="s">&quot;123&quot;</span>; <span class="c">// false.</span>
</pre></div>
<p>因为在Lox中我们不会做隐式类型转换（我极其反对隐式类型转换）。</p>
<h3><a href="#逻辑运算符" name="逻辑运算符"><small>3&#8202;.&#8202;4&#8202;.&#8202;3</small>逻辑运算符</a></h3>
<p>非操作符，是一个前缀<code>!</code>，如果操作数为真，返回<code>false</code>，操作数为假，返回<code>true</code>。</p>
<div class="codehilite"><pre>
!<span class="k">true</span>;  <span class="c">// false.</span>
!<span class="k">false</span>; <span class="c">// true.</span>
</pre></div>
<p>剩下两个逻辑运算符其实是伪装成表达式的控制流。<span name="and"><code>and</code></span>表达式只有当两个值都为true时才会返回true。如果<code>and</code>操作符的左边的值是false的话，那么表达式将返回左边的操作数。如果左边的操作数为true，则返回右边操作数的值。</p>
<div class="codehilite"><pre>
<span class="k">true</span> <span class="k">and</span> <span class="k">false</span>; <span class="c">// false.</span>
<span class="k">true</span> <span class="k">and</span> <span class="k">true</span>;  <span class="c">// true.</span>
</pre></div>
<p><code>or</code>表达式只要两个值中有至少一个true，就会返回true。如果左边的操作数为true，则返回左边操作数。如果左边操作数为false，则返回右边操作数。</p>
<div class="codehilite"><pre>
<span class="k">false</span> <span class="k">or</span> <span class="k">false</span>; <span class="c">// false.</span>
<span class="k">true</span> <span class="k">or</span> <span class="k">false</span>;  <span class="c">// true.</span>
</pre></div>
<aside name="and">
<p>我使用<code>and</code>和<code>or</code>来代替<code>&amp;&amp;</code>和<code>||</code>是因为Lox不需要<code>&amp;</code>和<code>|</code>来作为位运算操作符。如果引进了两个相同字符的操作符，却没有单个字符的操作符的话，会显得很奇怪。</p>
<p>我自己也喜欢使用单词而不是负号，因为上面两个操作符实际上是控制流结构，而非简单的操作符。</p>
</aside>
<p><code>and</code>和<code>or</code>是控制流结构的原因在于它们是<strong>短路求值（short-circuit）</strong>。当<code>and</code>运算符左边的操作数是false时，会直接返回左边的操作数，<code>and</code>表达式甚至不会对右侧的操作数进行<em>求值</em>。相对应的，如果<code>or</code>左侧的操作数为true，那么右侧的操作数也就被直接忽略掉了。</p>
<h3><a href="#优先级和分组" name="优先级和分组"><small>3&#8202;.&#8202;4&#8202;.&#8202;4</small>优先级和分组</a></h3>
<p>所有的这些操作符拥有和C语言里面同样的优先级和结合性。（当我们到了解析这个阶段，我们会理解的更加精准。）如果想要改变优先级，可以使用<code>()</code>括号来进行分组。</p>
<div class="codehilite"><pre>
<span class="k">var</span> <span class="i">average</span> = (<span class="i">min</span> + <span class="i">max</span>) / <span class="n">2</span>;
</pre></div>
<p>我去掉了一些典型的操作符，例如位运算操作符、移位运算符、求余运算符以及条件运算符。因为这些从技术上实现来说，意思不大。当然我希望你能够自己实现这些运算符，这样会锻炼你的编程能力。</p>
<p>以上就是我们要介绍的Lox中的表达式，接下来，让我们再往上走一层。</p>
<h2><a href="#语句" name="语句"><small>3&#8202;.&#8202;5</small>语句</a></h2>
<p>现在我们来到了语句。表达式的主要任务是求值，或者说产生一个<em>值</em>。而语句的任务是产生一个<em>作用</em>。因为根据定义，语句并不会进行求值，语句的用处在于在某种程度上改变世界——通常情况下会修改一些状态，读取输出，以及产生输出。</p>
<p>你已经见过很多种类型的语句了。第一个就是：</p>
<div class="codehilite"><pre>
<span class="k">print</span> <span class="s">&quot;Hello, world!&quot;</span>;
</pre></div>
<p><span name="print"><code>print</code>语句</span>先对一个字符串进行求值，然后将求值结果显示给用户。你已经看到过一些像下面一样的表达式：</p>
<aside name="print">
<p>将<code>print</code>直接做进语言里，而不是把<code>print</code>做进标准库里，是一种简单粗暴的方法。但对我们来说很有用：它意味着在我们构建解释器的过程中，就可以不断的产生输出了。否则我们还需要先实现定义函数，使用函数名查找，以及调用函数这些功能。</p>
</aside>
<div class="codehilite"><pre>
<span class="s">&quot;some expression&quot;</span>;
</pre></div>
<p>一个表达式结尾跟上一个分号（<code>;</code>)，就将表达式提升为语句了。通常叫这样的语句为<strong>表达式语句</strong>。</p>
<p>如果你想将多个语句打包成一个语句，你可以使用花括号将多个语句包起来，放在一个<strong>块</strong>中。</p>
<div class="codehilite"><pre>
{
  <span class="k">print</span> <span class="s">&quot;One statement.&quot;</span>;
  <span class="k">print</span> <span class="s">&quot;Two statements.&quot;</span>;
}
</pre></div>
<p>块会影响作用域，下一节我们就会讲解这个概念<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span></p>
<h2><a href="#变量" name="变量"><small>3&#8202;.&#8202;6</small>变量</a></h2>
<p>我们使用<code>var</code>这个关键字来定义变量。如果变量<span name="omit">没有</span>初始值，那么变量的默认值是<code>nil</code>。</p>
<aside name="omit">
<p>如果在编程语言中去掉<code>nil</code>值，然后强制要求每一个变量必须被初始化成某一个值，比有<code>nil</code>这个值，会让人处理起来更加头痛。</p>
</aside>
<div class="codehilite"><pre>
<span class="k">var</span> <span class="i">imAVariable</span> = <span class="s">&quot;here is my value&quot;</span>;
<span class="k">var</span> <span class="i">iAmNil</span>;
</pre></div>
<p>变量一旦声明，我们就可以使用变量名来访问变量的值，也可以对变量名进行赋值了。</p>
<p><span name="breakfast"></span></p>
<div class="codehilite"><pre>
<span class="k">var</span> <span class="i">breakfast</span> = <span class="s">&quot;bagels&quot;</span>;
<span class="k">print</span> <span class="i">breakfast</span>; <span class="c">// &quot;bagels&quot;.</span>
<span class="i">breakfast</span> = <span class="s">&quot;beignets&quot;</span>;
<span class="k">print</span> <span class="i">breakfast</span>; <span class="c">// &quot;beignets&quot;.</span>
</pre></div>
<aside name="breakfast">
<p>你知道我为什么倾向于在吃早餐之前写书吗？</p>
</aside>
<p>我这里不打算讨论有关变量的作用域的问题，因为后面我们会花大量的时间来研究变量作用域的各种规则。在大多数情况下，Lox的变量作用域规则和C还有Java都差不多。</p>
<h2><a href="#控制流" name="控制流"><small>3&#8202;.&#8202;7</small>控制流</a></h2>
<p>如果我们无法跳过一些代码，也无法多次执行一段代码，那么我们很难写出<span name="flow">有用的</span>程序。跳过代码和多次执行代码指的就是控制流结构。除了我们上边说的逻辑运算符以外，Lox还有三种控制流结构，这些控制流结构直接来自C语言。</p>
<aside name="flow">
<p>我们已经有了<code>and</code>和<code>or</code>来实现分支结构，然后我们<em>可以</em>使用递归来重复执行代码，所以从理论上来说我们想要的控制流结构已经都能够实现了。只是使用命令式风格的语言来通过<code>and</code>、<code>or</code>和递归来实现控制流结构，会显得非常别扭（说白了就是在用命令式语言进行函数式编程）。</p>
<p>Scheme这门语言就是没有内建的循环结构。它依赖于递归来实现代码的重复执行。Smalltalk这门语言没有内建的分支结构，它通过动态分派机制来选择性的执行代码。</p>
</aside>
<p><code>if</code>语句基于某些条件来选择执行两个语句中的一个。</p>
<div class="codehilite"><pre>
<span class="k">if</span> (<span class="i">condition</span>) {
  <span class="k">print</span> <span class="s">&quot;yes&quot;</span>;
} <span class="k">else</span> {
  <span class="k">print</span> <span class="s">&quot;no&quot;</span>;
}
</pre></div>
<p><code>while</code><span name="do">循环</span>会重复的执行循环体，只要循环条件表达式一直求值为true。</p>
<div class="codehilite"><pre>
<span class="k">var</span> <span class="i">a</span> = <span class="n">1</span>;
<span class="k">while</span> (<span class="i">a</span> &lt; <span class="n">10</span>) {
  <span class="k">print</span> <span class="i">a</span>;
  <span class="i">a</span> = <span class="i">a</span> + <span class="n">1</span>;
}
</pre></div>
<aside name="do">
<p>我没有在Lox实现<code>do while</code>循环这种语法，因为这种语法用的很少。而且我们已经实现了<code>while</code>循环语句，再去实现<code>do while</code>循环语句，也不会让我们学会任何新的东西。如果你想的话，可以自己实现一下。</p>
</aside>
<p>最后，我们实现了<code>for</code>循环。</p>
<div class="codehilite"><pre>
<span class="k">for</span> (<span class="k">var</span> <span class="i">a</span> = <span class="n">1</span>; <span class="i">a</span> &lt; <span class="n">10</span>; <span class="i">a</span> = <span class="i">a</span> + <span class="n">1</span>) {
  <span class="k">print</span> <span class="i">a</span>;
}
</pre></div>
<p><code>for</code>循环做的事情和<code>while</code>循环是一样的。很多现代语言里面还有类似于<span name="foreach"><code>for-in</code></span>或者<code>foreach</code>循环这样的语法，为了能够明确的去迭代不同类型的序列。在一门真正的编程语言中，这些都比C风格的<code>for</code>循环更加好用。Lox只实现了C风格的<code>for</code>循环。</p>
<aside name="foreach">
<p>我之所以做出这样的让步，是因为解释器的实现被划分成了多个章节。<code>for-in</code>循环需要在迭代器协议中进行某种动态分配来处理不同种类的序列，但是直到在完成控制流的实现之后。我们才能回来并添加<code>for-in</code>循环。但我认为这样做不会教给你任何超级有趣的东西。</p>
</aside>
<h2><a href="#函数" name="函数"><small>3&#8202;.&#8202;8</small>函数</a></h2>
<p>函数调用表达式看起来和C语言是一样的。</p>
<div class="codehilite"><pre>
<span class="i">makeBreakfast</span>(<span class="i">bacon</span>, <span class="i">eggs</span>, <span class="i">toast</span>);
</pre></div>
<p>你也可以不给函数传任何参数，然后直接调用函数。</p>
<div class="codehilite"><pre>
<span class="i">makeBreakfast</span>();
</pre></div>
<p>不像在Ruby里面，在这里，函数调用的括号是强制必须写的。如果没有写括号，只有一个函数名，那么就不是再<em>调用</em>函数，而只是函数的引用而已。</p>
<p>如果无法定义自己的函数，一门语言写起来会很无聊。在Lox中，我们可以使用<span name="fun"><code>fun</code></span>关键字来定义函数。</p>
<aside name="fun">
<p>我见过很多语言使用<code>fn</code>，<code>fun</code>，<code>func</code>以及<code>function</code>这样的关键字来定义函数。我有点希望见到某些语言中，使用<code>funct</code>，<code>functi</code>和<code>functio</code>这样诡异的关键字来定义函数。</p>
</aside>
<div class="codehilite"><pre>
<span class="k">fun</span> <span class="i">printSum</span>(<span class="i">a</span>, <span class="i">b</span>) {
  <span class="k">print</span> <span class="i">a</span> + <span class="i">b</span>;
}
</pre></div>
<p>现在是时候澄清一些<span name="define">术语</span>了。很多人觉得&ldquo;parameter&rdquo;和&ldquo;argument&rdquo;是可以互换的术语，在很多情况下，它们确实指的是相同的意思。接下来我们会花很多的时间来细致的区分一些术语的语义，把我们对术语的运用打磨的精细一些。从现在就开始吧：</p>
<ul>
<li>
<p>一个<strong>参数（argument）<strong>是当我们调用函数时，传给函数的实际存在的参数。所以一个函数<em>调用</em>一个<em>参数</em>列表。我们经常听到叫这种参数是</strong>实在参数（actual parameter）</strong>。（“实在参数”这里，我使用了龙书里的翻译。）</p>
</li>
<li>
<p>一个<strong>参数（parameter）<strong>是一个变量，这个变量负责在函数体中保存实际参数（argument）的值。所以，一个函数<em>声明</em>中会有一个<em>参数</em>列表。我们经常听到叫这种参数是</strong>形式参数（formal parameters）<strong>或者</strong>形参（formals）</strong>。</p>
</li>
</ul>
<aside name="define">
<p>说到术语，一些像C语言这样的静态类型语言，会在函数的<em>声明</em>和<em>定义</em>之间作区分。一个声明将函数的类型和函数的名字绑定在了一起。这样当我们调用这个函数的时候，不需要定义好函数体就可以进行类型检查。一个定义是指不仅仅声明了函数的类型（输入参数类型和返回值类型就是一个函数的类型），还定义了函数体。所以这个函数就可以进行编译了。</p>
<p>由于Lox是动态类型语言，所以这个区分就没什么意义了。在动态类型语言中，一个函数的定义会完整的包含函数体的代码。</p>
</aside>
<p>函数体通常是一个<strong>块</strong>（也就是花括号括起来的）。在函数体中，你可以使用<code>return</code>语句来返回值。</p>
<div class="codehilite"><pre>
<span class="k">fun</span> <span class="i">returnSum</span>(<span class="i">a</span>, <span class="i">b</span>) {
  <span class="k">return</span> <span class="i">a</span> + <span class="i">b</span>;
}
</pre></div>
<p>如果程序执行到了块的末尾都没碰到<code>return</code>语句，那么函数体将会<span name="sneaky">隐式的</span>返回<code>nil</code>值。</p>
<aside name="sneaky">
<p>看，我和你说过吧，<code>nil</code>不知道什么时候就会在我们看不见的地方冒出来。</p>
</aside>
<h3><a href="#闭包" name="闭包"><small>3&#8202;.&#8202;8&#8202;.&#8202;1</small>闭包</a></h3>
<p>Functions are <em>first class</em> in Lox, which just means they are real values that
you can get a reference to, store in variables, pass around, etc. This works:</p>
<div class="codehilite"><pre>
<span class="k">fun</span> <span class="i">addPair</span>(<span class="i">a</span>, <span class="i">b</span>) {
  <span class="k">return</span> <span class="i">a</span> + <span class="i">b</span>;
}

<span class="k">fun</span> <span class="i">identity</span>(<span class="i">a</span>) {
  <span class="k">return</span> <span class="i">a</span>;
}

<span class="k">print</span> <span class="i">identity</span>(<span class="i">addPair</span>)(<span class="n">1</span>, <span class="n">2</span>); <span class="c">// Prints &quot;3&quot;.</span>
</pre></div>
<p>Since function declarations are statements, you can declare local functions
inside another function.</p>
<div class="codehilite"><pre>
<span class="k">fun</span> <span class="i">outerFunction</span>() {
  <span class="k">fun</span> <span class="i">localFunction</span>() {
    <span class="k">print</span> <span class="s">&quot;I&#39;m local!&quot;</span>;
  }

  <span class="i">localFunction</span>();
}
</pre></div>
<p>If you combine local functions, first-class functions, and block scope, you run
into this interesting situation:</p>
<div class="codehilite"><pre>
<span class="k">fun</span> <span class="i">returnFunction</span>() {
  <span class="k">var</span> <span class="i">outside</span> = <span class="s">&quot;outside&quot;</span>;

  <span class="k">fun</span> <span class="i">inner</span>() {
    <span class="k">print</span> <span class="i">outside</span>;
  }

  <span class="k">return</span> <span class="i">inner</span>;
}

<span class="k">var</span> <span class="i">fn</span> = <span class="i">returnFunction</span>();
<span class="i">fn</span>();
</pre></div>
<p>Here, <code>inner()</code> accesses a local variable declared outside of its body in the
surrounding function. Is this kosher? Now that lots of languages have borrowed
this feature from Lisp, you probably know the answer is yes.</p>
<p>For that to work, <code>inner()</code> has to &ldquo;hold on&rdquo; to references to any surrounding
variables that it uses so that they stay around even after the outer function
has returned. We call functions that do this <span
name="closure"><strong>closures</strong></span>. These days, the term is often used for <em>any</em>
first-class function, though it&rsquo;s sort of a misnomer if the function doesn&rsquo;t
happen to close over any variables.</p>
<aside name="closure">
<p>Peter J. Landin coined the term &ldquo;closure&rdquo;. Yes, he invented damn near half the
terms in programming languages. Most of them came out of one incredible paper,
&ldquo;<a href="https://homepages.inf.ed.ac.uk/wadler/papers/papers-we-love/landin-next-700.pdf">The Next 700 Programming Languages</a>&rdquo;.</p>
<p>In order to implement these kind of functions, you need to create a data
structure that bundles together the function&rsquo;s code and the surrounding
variables it needs. He called this a &ldquo;closure&rdquo; because it <em>closes over</em> and
holds on to the variables it needs.</p>
</aside>
<p>As you can imagine, implementing these adds some complexity because we can no
longer assume variable scope works strictly like a stack where local variables
evaporate the moment the function returns. We&rsquo;re going to have a fun time
learning how to make these work correctly and efficiently.</p>
<h2><a href="#类" name="类"><small>3&#8202;.&#8202;9</small>类</a></h2>
<p>Since Lox has dynamic typing, lexical (roughly, &ldquo;block&rdquo;) scope, and closures,
it&rsquo;s about halfway to being a functional language. But as you&rsquo;ll see, it&rsquo;s
<em>also</em> about halfway to being an object-oriented language. Both paradigms have a
lot going for them, so I thought it was worth covering some of each.</p>
<p>Since classes have come under fire for not living up to their hype, let me first
explain why I put them into Lox and this book. There are really two questions:</p>
<h3><a href="#why-might-any-language-want-to-be-object-oriented" name="why-might-any-language-want-to-be-object-oriented"><small>3&#8202;.&#8202;9&#8202;.&#8202;1</small>Why might any language want to be object oriented?</a></h3>
<p>Now that object-oriented languages like Java have sold out and only play arena
shows, it&rsquo;s not cool to like them anymore. Why would anyone make a <em>new</em>
language with objects? Isn&rsquo;t that like releasing music on 8-track?</p>
<p>It is true that the &ldquo;all inheritance all the time&rdquo; binge of the &rsquo;90s produced
some monstrous class hierarchies, but <strong>object-oriented programming</strong> (<strong>OOP</strong>)
is still pretty rad. Billions of lines of successful code have been written in
OOP languages, shipping millions of apps to happy users. Likely a majority of
working programmers today are using an object-oriented language. They can&rsquo;t all
be <em>that</em> wrong.</p>
<p>In particular, for a dynamically typed language, objects are pretty handy. We
need <em>some</em> way of defining compound data types to bundle blobs of stuff
together.</p>
<p>If we can also hang methods off of those, then we avoid the need to prefix all
of our functions with the name of the data type they operate on to avoid
colliding with similar functions for different types. In, say, Racket, you end
up having to name your functions like <code>hash-copy</code> (to copy a hash table) and
<code>vector-copy</code> (to copy a vector) so that they don&rsquo;t step on each other. Methods
are scoped to the object, so that problem goes away.</p>
<h3><a href="#为什么lox是一门面向对象语言？" name="为什么lox是一门面向对象语言？"><small>3&#8202;.&#8202;9&#8202;.&#8202;2</small>为什么Lox是一门面向对象语言？</a></h3>
<p>I could claim objects are groovy but still out of scope for the book. Most
programming language books, especially ones that try to implement a whole
language, leave objects out. To me, that means the topic isn&rsquo;t well covered.
With such a widespread paradigm, that omission makes me sad.</p>
<p>Given how many of us spend all day <em>using</em> OOP languages, it seems like the
world could use a little documentation on how to <em>make</em> one. As you&rsquo;ll see, it
turns out to be pretty interesting. Not as hard as you might fear, but not as
simple as you might presume, either.</p>
<h3><a href="#类还是原型" name="类还是原型"><small>3&#8202;.&#8202;9&#8202;.&#8202;3</small>类还是原型</a></h3>
<p>When it comes to objects, there are actually two approaches to them, <a href="https://en.wikipedia.org/wiki/Class-based_programming">classes</a>
and <a href="https://en.wikipedia.org/wiki/Prototype-based_programming">prototypes</a>. Classes came first, and are more common thanks to C++, Java,
C#, and friends. Prototypes were a virtually forgotten offshoot until JavaScript
accidentally took over the world.</p>
<p>In class-based languages, there are two core concepts: instances and classes.
Instances store the state for each object and have a reference to the instance&rsquo;s
class. Classes contain the methods and inheritance chain. To call a method on an
instance, there is always a level of indirection. You look up the instance&rsquo;s
class and then you find the method <em>there</em>:</p><img src="image/the-lox-language/class-lookup.png" alt="How fields and methods are looked up on classes and instances" />
<p>Prototype-based languages <span name="blurry">merge</span> these two concepts.
There are only objects<span class="em">&mdash;</span>no classes<span class="em">&mdash;</span>and each individual object may contain
state and methods. Objects can directly inherit from each other (or &ldquo;delegate
to&rdquo; in prototypal lingo):</p>
<aside name="blurry">
<p>In practice the line between class-based and prototype-based languages blurs.
JavaScript&rsquo;s &ldquo;constructor function&rdquo; notion <a href="http://gameprogrammingpatterns.com/prototype.html#what-about-javascript">pushes you pretty hard</a>
towards defining class-like objects. Meanwhile, class-based Ruby is perfectly
happy to let you attach methods to individual instances.</p>
</aside><img src="image/the-lox-language/prototype-lookup.png" alt="How fields and methods are looked up in a prototypal system" />
<p>This means that in some ways prototypal languages are more fundamental than
classes. They are really neat to implement because they&rsquo;re <em>so</em> simple. Also,
they can express lots of unusual patterns that classes steer you away from.</p>
<p>But I&rsquo;ve looked at a <em>lot</em> of code written in prototypal languages<span class="em">&mdash;</span>including
<a href="http://finch.stuffwithstuff.com/">some of my own devising</a>. Do you know what people generally do with all
of the power and flexibility of prototypes? <span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>They use them to reinvent
classes.</p>
<p>I don&rsquo;t know <em>why</em> that is, but people naturally seem to prefer a class-based
(Classic? Classy?) style. Prototypes <em>are</em> simpler in the language, but they
seem to accomplish that only by <span name="waterbed">pushing</span> the
complexity onto the user. So, for Lox, we&rsquo;ll save our users the trouble and bake
classes right in.</p>
<aside name="waterbed">
<p>Larry Wall, Perl&rsquo;s inventor/prophet calls this the &ldquo;<a href="http://wiki.c2.com/?WaterbedTheory">waterbed theory</a>&rdquo;. Some
complexity is essential and cannot be eliminated. If you push it down in one
place, it swells up in another.</p>
<p>Prototypal languages don&rsquo;t so much <em>eliminate</em> the complexity of classes as they
do make the <em>user</em> take that complexity by building their own class-like
metaprogramming libraries.</p>
</aside>
<h3><a href="#lox中的类" name="lox中的类"><small>3&#8202;.&#8202;9&#8202;.&#8202;4</small>Lox中的类</a></h3>
<p>Enough rationale, let&rsquo;s see what we actually have. Classes encompass a
constellation of features in most languages. For Lox, I&rsquo;ve selected what I think
are the brightest stars. You declare a class and its methods like so:</p>
<div class="codehilite"><pre>
<span class="k">class</span> <span class="t">Breakfast</span> {
  <span class="i">cook</span>() {
    <span class="k">print</span> <span class="s">&quot;Eggs a-fryin&#39;!&quot;</span>;
  }

  <span class="i">serve</span>(<span class="i">who</span>) {
    <span class="k">print</span> <span class="s">&quot;Enjoy your breakfast, &quot;</span> + <span class="i">who</span> + <span class="s">&quot;.&quot;</span>;
  }
}
</pre></div>
<p>The body of a class contains its methods. They look like function declarations
but without the <code>fun</code> <span name="method">keyword</span>. When the class
declaration is executed, Lox creates a class object and stores that in a
variable named after the class. Just like functions, classes are first class in
Lox.</p>
<aside name="method">
<p>They are still just as fun, though.</p>
</aside>
<div class="codehilite"><pre>
<span class="c">// Store it in variables.</span>
<span class="k">var</span> <span class="i">someVariable</span> = <span class="t">Breakfast</span>;

<span class="c">// Pass it to functions.</span>
<span class="i">someFunction</span>(<span class="t">Breakfast</span>);
</pre></div>
<p>Next, we need a way to create instances. We could add some sort of <code>new</code>
keyword, but to keep things simple, in Lox the class itself is a factory
function for instances. Call a class like a function, and it produces a new
instance of itself.</p>
<div class="codehilite"><pre>
<span class="k">var</span> <span class="i">breakfast</span> = <span class="t">Breakfast</span>();
<span class="k">print</span> <span class="i">breakfast</span>; <span class="c">// &quot;Breakfast instance&quot;.</span>
</pre></div>
<h3><a href="#instantiation-and-initialization" name="instantiation-and-initialization"><small>3&#8202;.&#8202;9&#8202;.&#8202;5</small>Instantiation and initialization</a></h3>
<p>Classes that only have behavior aren&rsquo;t super useful. The idea behind
object-oriented programming is encapsulating behavior <em>and state</em> together. To
do that, you need fields. Lox, like other dynamically typed languages, lets you
freely add properties onto objects.</p>
<div class="codehilite"><pre>
<span class="i">breakfast</span>.<span class="i">meat</span> = <span class="s">&quot;sausage&quot;</span>;
<span class="i">breakfast</span>.<span class="i">bread</span> = <span class="s">&quot;sourdough&quot;</span>;
</pre></div>
<p>Assigning to a field creates it if it doesn&rsquo;t already exist.</p>
<p>If you want to access a field or method on the current object from within a
method, you use good old <code>this</code>.</p>
<div class="codehilite"><pre>
<span class="k">class</span> <span class="t">Breakfast</span> {
  <span class="i">serve</span>(<span class="i">who</span>) {
    <span class="k">print</span> <span class="s">&quot;Enjoy your &quot;</span> + <span class="k">this</span>.<span class="i">meat</span> + <span class="s">&quot; and &quot;</span> +
        <span class="k">this</span>.<span class="i">bread</span> + <span class="s">&quot;, &quot;</span> + <span class="i">who</span> + <span class="s">&quot;.&quot;</span>;
  }

  <span class="c">// ...</span>
}
</pre></div>
<p>Part of encapsulating data within an object is ensuring the object is in a valid
state when it&rsquo;s created. To do that, you can define an initializer. If your
class has a method named <code>init()</code>, it is called automatically when the object is
constructed. Any parameters passed to the class are forwarded to its
initializer.</p>
<div class="codehilite"><pre>
<span class="k">class</span> <span class="t">Breakfast</span> {
  <span class="i">init</span>(<span class="i">meat</span>, <span class="i">bread</span>) {
    <span class="k">this</span>.<span class="i">meat</span> = <span class="i">meat</span>;
    <span class="k">this</span>.<span class="i">bread</span> = <span class="i">bread</span>;
  }

  <span class="c">// ...</span>
}

<span class="k">var</span> <span class="i">baconAndToast</span> = <span class="t">Breakfast</span>(<span class="s">&quot;bacon&quot;</span>, <span class="s">&quot;toast&quot;</span>);
<span class="i">baconAndToast</span>.<span class="i">serve</span>(<span class="s">&quot;Dear Reader&quot;</span>);
<span class="c">// &quot;Enjoy your bacon and toast, Dear Reader.&quot;</span>
</pre></div>
<h3><a href="#继承" name="继承"><small>3&#8202;.&#8202;9&#8202;.&#8202;6</small>继承</a></h3>
<p>Every object-oriented language lets you not only define methods, but reuse them
across multiple classes or objects. For that, Lox supports single inheritance.
When you declare a class, you can specify a class that it inherits from using a less-than
<span name="less">(<code>&lt;</code>)</span> operator.</p>
<div class="codehilite"><pre>
<span class="k">class</span> <span class="t">Brunch</span> &lt; <span class="t">Breakfast</span> {
  <span class="i">drink</span>() {
    <span class="k">print</span> <span class="s">&quot;How about a Bloody Mary?&quot;</span>;
  }
}
</pre></div>
<aside name="less">
<p>Why the <code>&lt;</code> operator? I didn&rsquo;t feel like introducing a new keyword like
<code>extends</code>. Lox doesn&rsquo;t use <code>:</code> for anything else so I didn&rsquo;t want to reserve
that either. Instead, I took a page from Ruby and used <code>&lt;</code>.</p>
<p>If you know any type theory, you&rsquo;ll notice it&rsquo;s not a <em>totally</em> arbitrary
choice. Every instance of a subclass is an instance of its superclass too, but
there may be instances of the superclass that are not instances of the subclass.
That means, in the universe of objects, the set of subclass objects is smaller
than the superclass&rsquo;s set, though type nerds usually use <code>&lt;:</code> for that relation.</p>
</aside>
<p>Here, Brunch is the <strong>derived class</strong> or <strong>subclass</strong>, and Breakfast is the
<strong>base class</strong> or <strong>superclass</strong>.</p>
<p>Every method defined in the superclass is also available to its subclasses.</p>
<div class="codehilite"><pre>
<span class="k">var</span> <span class="i">benedict</span> = <span class="t">Brunch</span>(<span class="s">&quot;ham&quot;</span>, <span class="s">&quot;English muffin&quot;</span>);
<span class="i">benedict</span>.<span class="i">serve</span>(<span class="s">&quot;Noble Reader&quot;</span>);
</pre></div>
<p>Even the <code>init()</code> method gets <span name="init">inherited</span>. In practice,
the subclass usually wants to define its own <code>init()</code> method too. But the
original one also needs to be called so that the superclass can maintain its
state. We need some way to call a method on our own <em>instance</em> without hitting
our own <em>methods</em>.</p>
<aside name="init">
<p>Lox is different from C++, Java, and C#, which do not inherit constructors, but
similar to Smalltalk and Ruby, which do.</p>
</aside>
<p>As in Java, you use <code>super</code> for that.</p>
<div class="codehilite"><pre>
<span class="k">class</span> <span class="t">Brunch</span> &lt; <span class="t">Breakfast</span> {
  <span class="i">init</span>(<span class="i">meat</span>, <span class="i">bread</span>, <span class="i">drink</span>) {
    <span class="k">super</span>.<span class="i">init</span>(<span class="i">meat</span>, <span class="i">bread</span>);
    <span class="k">this</span>.<span class="i">drink</span> = <span class="i">drink</span>;
  }
}
</pre></div>
<p>That&rsquo;s about it for object orientation. I tried to keep the feature set minimal.
The structure of the book did force one compromise. Lox is not a <em>pure</em>
object-oriented language. In a true OOP language every object is an instance of
a class, even primitive values like numbers and Booleans.</p>
<p>Because we don&rsquo;t implement classes until well after we start working with the
built-in types, that would have been hard. So values of primitive types aren&rsquo;t
real objects in the sense of being instances of classes. They don&rsquo;t have methods
or properties. If I were trying to make Lox a real language for real users, I
would fix that.</p>
<h2><a href="#标准库" name="标准库"><small>3&#8202;.&#8202;10</small>标准库</a></h2>
<p>We&rsquo;re almost done. That&rsquo;s the whole language, so all that&rsquo;s left is the &ldquo;core&rdquo;
or &ldquo;standard&rdquo; library<span class="em">&mdash;</span>the set of functionality that is implemented directly
in the interpreter and that all user-defined behavior is built on top of.</p>
<p>This is the saddest part of Lox. Its standard library goes beyond minimalism and
veers close to outright nihilism. For the sample code in the book, we only need
to demonstrate that code is running and doing what it&rsquo;s supposed to do. For
that, we already have the built-in <code>print</code> statement.</p>
<p>Later, when we start optimizing, we&rsquo;ll write some benchmarks and see how long it
takes to execute code. That means we need to track time, so we&rsquo;ll define one
built-in function, <code>clock()</code>, that returns the number of seconds since the
program started.</p>
<p>And<span class="ellipse">&thinsp;.&thinsp;.&thinsp;.&nbsp;</span>that&rsquo;s it. I know, right? It&rsquo;s embarrassing.</p>
<p>If you wanted to turn Lox into an actual useful language, the very first thing
you should do is flesh this out. String manipulation, trigonometric functions,
file I/O, networking, heck, even <em>reading input from the user</em> would help. But we
don&rsquo;t need any of that for this book, and adding it wouldn&rsquo;t teach you anything
interesting, so I&rsquo;ve left it out.</p>
<p>Don&rsquo;t worry, we&rsquo;ll have plenty of exciting stuff in the language itself to keep
us busy.</p>
<div class="challenges">
<h2><a href="#挑战" name="挑战"><small>3&#8202;.&#8202;11</small>挑战</a></h2>
<ol>
<li>
<p>Write some sample Lox programs and run them (you can use the implementations
of Lox in <a href="https://github.com/confucianzuoyuan/craftinginterpreters">my repository</a>). Try to come up with edge case behavior I
didn&rsquo;t specify here. Does it do what you expect? Why or why not?</p>
</li>
<li>
<p>This informal introduction leaves a <em>lot</em> unspecified. List several open
questions you have about the language&rsquo;s syntax and semantics. What do you
think the answers should be?</p>
</li>
<li>
<p>Lox is a pretty tiny language. What features do you think it is missing that
would make it annoying to use for real programs? (Aside from the standard
library, of course.)</p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="#语言设计笔记：表达式和语句" name="语言设计笔记：表达式和语句"><small>3&#8202;.&#8202;12</small>语言设计笔记：表达式和语句</a></h2>
<p>Lox has both expressions and statements. Some languages omit the latter.
Instead, they treat declarations and control flow constructs as expressions too.
These &ldquo;everything is an expression&rdquo; languages tend to have functional pedigrees
and include most Lisps, SML, Haskell, Ruby, and CoffeeScript.</p>
<p>To do that, for each &ldquo;statement-like&rdquo; construct in the language, you need to
decide what value it evaluates to. Some of those are easy:</p>
<ul>
<li>
<p>An <code>if</code> expression evaluates to the result of whichever branch is chosen.
Likewise, a <code>switch</code> or other multi-way branch evaluates to whichever case
is picked.</p>
</li>
<li>
<p>A variable declaration evaluates to the value of the variable.</p>
</li>
<li>
<p>A block evaluates to the result of the last expression in the sequence.</p>
</li>
</ul>
<p>Some get a little stranger. What should a loop evaluate to? A <code>while</code> loop in
CoffeeScript evaluates to an array containing each element that the body
evaluated to. That can be handy, or a waste of memory if you don&rsquo;t need the
array.</p>
<p>You also have to decide how these statement-like expressions compose with other
expressions<span class="em">&mdash;</span>you have to fit them into the grammar&rsquo;s precedence table. For
example, Ruby allows:</p>
<div class="codehilite"><pre>
<span class="i">puts</span> <span class="n">1</span> + <span class="k">if</span> <span class="k">true</span> <span class="k">then</span> <span class="n">2</span> <span class="k">else</span> <span class="n">3</span> <span class="k">end</span> + <span class="n">4</span>
</pre></div>
<p>Is this what you&rsquo;d expect? Is it what your <em>users</em> expect? How does this affect
how you design the syntax for your &ldquo;statements&rdquo;? Note that Ruby has an explicit
<code>end</code> to tell when the <code>if</code> expression is complete. Without it, the <code>+ 4</code> would
likely be parsed as part of the <code>else</code> clause.</p>
<p>Turning every statement into an expression forces you to answer a few hairy
questions like that. In return, you eliminate some redundancy. C has both blocks
for sequencing statements, and the comma operator for sequencing expressions. It
has both the <code>if</code> statement and the <code>?:</code> conditional operator. If everything was
an expression in C, you could unify each of those.</p>
<p>Languages that do away with statements usually also feature <strong>implicit returns</strong><span class="em">&mdash;</span>a function automatically returns whatever value its body evaluates to without
need for some explicit <code>return</code> syntax. For small functions and methods, this is
really handy. In fact, many languages that do have statements have added syntax
like <code>=&gt;</code> to be able to define functions whose body is the result of evaluating
a single expression.</p>
<p>But making <em>all</em> functions work that way can be a little strange. If you aren&rsquo;t
careful, your function will leak a return value even if you only intend it to
produce a side effect. In practice, though, users of these languages don&rsquo;t find
it to be a problem.</p>
<p>For Lox, I gave it statements for prosaic reasons. I picked a C-like syntax for
familiarity&rsquo;s sake, and trying to take the existing C statement syntax and
interpret it like expressions gets weird pretty fast.</p>
</div>

<footer>
<a href="a-tree-walk-interpreter.html" class="next">
  Next Part: &ldquo;A Tree-Walk Interpreter&rdquo; &rarr;
</a>
Robert Nystrom 著  左元 译&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2020</a>
</footer>
</article>

</div>
</body>
</html>
