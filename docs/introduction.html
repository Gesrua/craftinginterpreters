<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>介绍 &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype-small.png" title="Crafting Interpreters"></a>
  <div class="contents">
<!-- If there is a part, it must be a chapter within a part. -->
<h3><a href="#top">介绍<small>1</small></a></h3>

<ul>
    <li><a href="#为什么要学习这些东西？"><small>1.1</small> 为什么要学习这些东西？</a></li>
    <li><a href="#how-the-book-is-organized"><small>1.2</small> How the Book Is Organized</a></li>
    <li><a href="#the-first-interpreter"><small>1.3</small> The First Interpreter</a></li>
    <li><a href="#the-second-interpreter"><small>1.4</small> The Second Interpreter</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
    <li class="end-part"><a href="#design-note"><small>note</small>What&#x27;s in a Name?</a></li>
</ul>


<div class="prev-next">
    <a href="welcome.html" title="欢迎" class="left">&larr;&nbsp;Previous</a>
    <a href="welcome.html" title="欢迎">&uarr;&nbsp;Up</a>
    <a href="a-map-of-the-territory.html" title="全书导航" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype-small.png" title="Crafting Interpreters"></a>
<a href="welcome.html" title="欢迎" class="prev">←</a>
<a href="a-map-of-the-territory.html" title="全书导航" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype-small.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<!-- If there is a part, it must be a chapter within a part. -->
<h3><a href="#top">介绍<small>1</small></a></h3>

<ul>
    <li><a href="#为什么要学习这些东西？"><small>1.1</small> 为什么要学习这些东西？</a></li>
    <li><a href="#how-the-book-is-organized"><small>1.2</small> How the Book Is Organized</a></li>
    <li><a href="#the-first-interpreter"><small>1.3</small> The First Interpreter</a></li>
    <li><a href="#the-second-interpreter"><small>1.4</small> The Second Interpreter</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
    <li class="end-part"><a href="#design-note"><small>note</small>What&#x27;s in a Name?</a></li>
</ul>


<div class="prev-next">
    <a href="welcome.html" title="欢迎" class="left">&larr;&nbsp;Previous</a>
    <a href="welcome.html" title="欢迎">&uarr;&nbsp;Up</a>
    <a href="a-map-of-the-territory.html" title="全书导航" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">1</div>
  <h1>介绍</h1>

<blockquote>
<p>童话故事超越了真实：不是因为童话故事告诉我们恶龙是存在的，而是因为童话故事告诉了我们恶龙是可以被击败的。</p>
<p><cite>G.K.切斯特顿</cite></p>
</blockquote>
<p>能够和大家一起踏上旅程，我非常激动。这是一本有关为编程语言实现解释器的书。同时也是一本有关如何设计一门有价值的编程语言的书。我非常希望在我投入到编程语言这个领域的初期就能碰到这样一本书。而这本书在我的<span
name="head">大脑中</span>中已经写了将近十年了。</p>
<aside name="head">
<p>这里要和我的家人和朋友们说声抱歉，抱歉这些年我是如此的不着调，如此的心不在焉（脑子里一直在写书）！</p>
</aside>
<p>在本书中，我们将会一步一步的为一门具有诸多特性的编程语言实现两个完整的解释器。这里我会假设本书的读者是初次涉猎编程语言这个领域。所以，构建一个完整的，可用的，运行速度快的编程语言所需要的每一个概念和每一行代码，本书都会详细讲解。</p>
<p>为了覆盖两个完整的解释器的实现，同时不会把读者劝退，书里面的内容相对于其他同类型的书籍，理论方面会偏弱一些。由于我们要构建解释器的每一个模块，所以我在构建每一个模块的时候，都会相对应的介绍模块背后的历史以及所涉及的概念。我会尽量让读者朋友熟悉所涉及的每一个术语，这样当你身处于一堆编程语言专家参加的<span name="party">鸡尾酒会</span>时，能够很好的融入进去。</p>
<aside name="party">
<p>有意思的是，这种场景我经历过很多次。他们中的一些人很能喝呢！</p>
</aside>
<p>我们主要的精力会花在将语言实现出来，跑起来。这并不是说理论是不重要的。对于编程语言理论这个领域，能够对编程语言的语法和语义进行严谨的且<span name="formal">形式化</span>的推理是非常重要的技能。但就我个人而言，通过实现一门语言来学习是一种最好的方式（learn by doing）。对我来说，读一本充满了抽象概念的书，很难真正的吸收它们（内涵龙书？哈哈）。但如果我能写一些代码，跑起来，调试一下，我就能真正<em>学会</em>这些知识。</p>
<aside name="formal">
<p>静态类型系统（Haskell，OCaml之类的语言）尤其需要严格的形式化推理。摆弄（hacking，我翻译成了摆弄）一个类型系统就好像是在做数学中的定理证明题。</p>
<p>类型系统和定理证明的相似性并不是巧合。在上个世纪的前半页，Haskell Curry和William Alvin Howard这两个人展示了类型系统和定理证明是一枚硬币的两面。<a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">Curry-Howard同构</a>。</p>
</aside>
<p>下面是我对读者朋友的一点期望。读完这本书以后，希望你们对真正的编程语言是如何工作的有强烈的直觉力。希望你们后面再读其他更加理论的书籍时，很多概念已经深深的扎根在你们的大脑中了，深深的印在了你们的脑海里。</p>
<h2><a href="#为什么要学习这些东西？" name="为什么要学习这些东西？"><small>1&#8202;.&#8202;1</small>为什么要学习这些东西？</a></h2>
<p>每一本介绍编译器的书都会有这一部分。我不太明白这些书为什么总是怀疑自己存在的必要性。比如鸟类学的书就不需要写“为什么要学习鸟类学”这种内容。它们通常假设读者是喜欢鸟儿的，然后就开始讲解了。</p>
<p>但是有关编程语言的书（编译器、编程语言理论）有一些不同。作为程序员，创建一门成功的、通用性的编程语言这个需求是非常罕见的。那些用的最多的编程语言（C、Java、Python等）既可以用在敞篷露营车，也可以用在大众公共汽车。这样的编程语言的设计者是最最顶尖的程序员。如果说想要进入这些人的行列是学习编程语言相关知识的<em>唯一</em>理由的话，那的确是没必要学的。幸好不是这样的，也就是是说每一个程序员都需要学习编程语言方面的知识。</p>
<h3><a href="#小型编程语言到处都是" name="小型编程语言到处都是"><small>1&#8202;.&#8202;1&#8202;.&#8202;1</small>小型编程语言到处都是</a></h3>
<p>相对于每一门成功的通用型编程语言，都有数以千计的成功的“小语言”。我们以前叫它们“小语言”，随着术语的“通货膨胀”，我们越来越倾向于叫它们“领域特定语言”（DSL，Domain-Specific Languages）。这些小小的语言都是为了特定的任务准备的。比如应用程序的脚本语言，模板引擎（Jinja2之类的），标记语言（Markdown，Asciidoc之类的），以及配置文件等等。</p>
<p><span name="little"></span><img src="image/introduction/little-languages.png" alt="A random selection of little languages." /></p>
<aside name="little">
<p>上面的图列举了一些你可能碰到过的小小语言。</p>
</aside>
<p>几乎每一个大型软件项目都需要很多种这样的小语言。正常情况来讲，我们最好去使用已有的编程语言，而不是自己造一个。自己造轮子要考虑的东西太多了：文档，调试器，对编辑器的支持，语法高亮，还有很多其他的坑。所以自己造轮子还是很费劲的。</p>
<p>但在一些非正常的情况下，你会发现你可能需要自己写一个解析器（parser）或者其他的工具。因为你想用的工具并不存在，只能自己写。即使你正在使用一些已有的工具，你可能也无法避免去调试这些工具，给这些工具修复错误（已有的工具所存在的bug很多！）。</p>
<h3><a href="#构建编程语言是一种伟大的练习方式" name="构建编程语言是一种伟大的练习方式"><small>1&#8202;.&#8202;1&#8202;.&#8202;2</small>构建编程语言是一种伟大的练习方式</a></h3>
<p>长跑运动员有时候会在他们的脚踝上负重，或者去高海拔而空气稀薄的地方进行训练。当他们卸下脚踝上的负重，并且来到海拔低的地方长跑时，轻松的脚踝和丰富的含氧量会让他们跑的更快，跑的更远。</p>
<p>实现一门编程语言是对编程水平的一种很真实的测验（比做算法题好，哈哈）。因为需要写的代码非常复杂，性能也至关重要。你必须熟练掌握递归，动态数组，树，图和哈希表。你可能每天都在用哈希表，但你<em>真的</em>彻底理解哈希表吗？好办，在亲手制作了我们自己的编程语言之后，我保证你会彻底理解哈希表。</p>
<p>我会向你展示实现一个解释器并不像你想象的那样是一件非常恐怖的事情。尽管如此，这件事依然是一个很大的挑战。克服了这个大的挑战，你将会成为一个更加强大的程序员，也能在你每天的工作中，更加聪明的去使用那些数据结构和算法。</p>
<h3><a href="#最后一个原因" name="最后一个原因"><small>1&#8202;.&#8202;1&#8202;.&#8202;3</small>最后一个原因</a></h3>
<p>最后一个原因对于我个人而言有点难以承认，因为这个原因隐藏在我的心底。当我还是个孩子的时候，我开始学习编程，编程语言有一些我觉得很神奇的东西。当我一个字母一个字母的敲出了一些BASIC程序时，我搞不明白BASIC<em>本身</em>是怎么实现出来的。</p>
<p>再后来，当我的大学朋友们谈起他们的编译器课程时，脸上浮现出的那种敬畏和恐惧，足以使我相信编程语言黑客是一种人类中的特殊物种——他们是一群魔术师，拥有操控某种密法的特权。</p>
<p>那是一幅诱人的<span name="image">图画</span>，但它也有黑暗的一面。<em>我</em>并没有自己是魔术师的感觉，所以我觉得我天生缺少一种特质，而只有拥有这种特质，才能进入魔术师的行列。尽管从我在学校的笔记本上写编程语言的关键字的时候开始，我就被编程语言深深的吸引。但过了很多年，我才能鼓起勇气去真正的尝试去学习它们。那种“魔术般”的特质，那种排他性，将<em>我</em>排除在外。</p>
<aside name="image">
<p>而编程语言领域的从业者们，也毫不犹豫的构建了这样一幅图画。两本有关编程语言的著名课本(SICP和龙书)将<a href="https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools">恶龙</a>和<a href="https://mitpress.mit.edu/sites/default/files/sicp/index.html">魔术师</a>作为了它们的封面。</p>
</aside>
<p>When I did finally start cobbling together my own little interpreters, I quickly
learned that, of course, there is no magic at all. It&rsquo;s just code, and the
people who hack on languages are just people.</p>
<p>There <em>are</em> a few techniques you don&rsquo;t often encounter outside of languages, and
some parts are a little difficult. But not more difficult than other obstacles
you&rsquo;ve overcome. My hope is that if you&rsquo;ve felt intimidated by languages and
this book helps you overcome that fear, maybe I&rsquo;ll leave you just a tiny bit
braver than you were before.</p>
<p>And, who knows, maybe you <em>will</em> make the next great language. Someone has to.</p>
<h2><a href="#how-the-book-is-organized" name="how-the-book-is-organized"><small>1&#8202;.&#8202;2</small>How the Book Is Organized</a></h2>
<p>This book is broken into three parts. You&rsquo;re reading the first one now. It&rsquo;s a
couple of chapters to get you oriented, teach you some of the lingo that
language hackers use, and introduce you to Lox, the language we&rsquo;ll be
implementing.</p>
<p>Each of the other two parts builds one complete Lox interpreter. Within those
parts, each chapter is structured the same way. The chapter takes a single
language feature, teaches you the concepts behind it, and walks you through an
implementation.</p>
<p>It took a good bit of trial and error on my part, but I managed to carve up the
two interpreters into chapter-sized chunks that build on the previous chapters
but require nothing from later ones. From the very first chapter, you&rsquo;ll have a
working program you can run and play with. With each passing chapter, it grows
increasingly full-featured until you eventually have a complete language.</p>
<p>Aside from copious, scintillating English prose, chapters have a few other
delightful facets:</p>
<h3><a href="#the-code" name="the-code"><small>1&#8202;.&#8202;2&#8202;.&#8202;1</small>The code</a></h3>
<p>We&rsquo;re about <em>crafting</em> interpreters, so this book contains real code. Every
single line of code needed is included, and each snippet tells you where to
insert it in your ever-growing implementation.</p>
<p>Many other language books and language implementations use tools like <a href="https://en.wikipedia.org/wiki/Lex_(software)">Lex</a>
and <span name="yacc"><a href="https://en.wikipedia.org/wiki/Yacc">Yacc</a></span>, so-called <strong>compiler-compilers</strong>, that
automatically generate some of the source files for an implementation from some
higher-level description. There are pros and cons to tools like those, and
strong opinions<span class="em">&mdash;</span>some might say religious convictions<span class="em">&mdash;</span>on both sides.</p>
<aside name="yacc">
<p>Yacc is a tool that takes in a grammar file and produces a source file for a
compiler, so it&rsquo;s sort of like a &ldquo;compiler&rdquo; that outputs a compiler, which is
where we get the term &ldquo;compiler-compiler&rdquo;.</p>
<p>Yacc wasn&rsquo;t the first of its ilk, which is why it&rsquo;s named &ldquo;Yacc&rdquo;<span class="em">&mdash;</span><em>Yet
Another</em> Compiler-Compiler. A later similar tool is <a href="https://en.wikipedia.org/wiki/GNU_bison">Bison</a>, named as a pun on
the pronunciation of Yacc like &ldquo;yak&rdquo;.</p><img src="image/introduction/yak.png" alt="A yak.">
<p>If you find all of these little self-references and puns charming and fun,
you&rsquo;ll fit right in here. If not, well, maybe the language nerd sense of humor
is an acquired taste.</p>
</aside>
<p>We will abstain from using them here. I want to ensure there are no dark corners
where magic and confusion can hide, so we&rsquo;ll write everything by hand. As you&rsquo;ll
see, it&rsquo;s not as bad as it sounds, and it means you really will understand each
line of code and how both interpreters work.</p>
<p>A book has different constraints from the &ldquo;real world&rdquo; and so the coding style
here might not always reflect the best way to write maintainable production
software. If I seem a little cavalier about, say, omitting <code>private</code> or
declaring a global variable, understand I do so to keep the code easier on your
eyes. The pages here aren&rsquo;t as wide as your IDE and every character counts.</p>
<p>Also, the code doesn&rsquo;t have many comments. That&rsquo;s because each handful of lines
is surrounded by several paragraphs of honest-to-God prose explaining it. When
you write a book to accompany your program, you are welcome to omit comments
too. Otherwise, you should probably use <code>//</code> a little more than I do.</p>
<p>While the book contains every line of code and teaches what each means, it does
not describe the machinery needed to compile and run the interpreter. I assume
you can slap together a makefile or a project in your IDE of choice in order to
get the code to run. Those kinds of instructions get out of date quickly, and
I want this book to age like XO brandy, not backyard hooch.</p>
<h3><a href="#snippets" name="snippets"><small>1&#8202;.&#8202;2&#8202;.&#8202;2</small>Snippets</a></h3>
<p>Since the book contains literally every line of code needed for the
implementations, the snippets are quite precise. Also, because I try to keep the
program in a runnable state even when major features are missing, sometimes we
add temporary code that gets replaced in later snippets.</p>
<p>A snippet with all the bells and whistles looks like this:</p>
<div class="codehilite"><pre class="insert-before">
      default:
</pre><div class="source-file"><em>lox/Scanner.java</em><br>
in <em>scanToken</em>()<br>
replace 1 line</div>
<pre class="insert">
        <span class="k">if</span> (<span class="i">isDigit</span>(<span class="i">c</span>)) {
          <span class="i">number</span>();
        } <span class="k">else</span> {
          <span class="t">Lox</span>.<span class="i">error</span>(<span class="i">line</span>, <span class="s">&quot;Unexpected character.&quot;</span>);
        }
</pre><pre class="insert-after">
        break;
</pre></div>
<div class="source-file-narrow"><em>lox/Scanner.java</em>, in <em>scanToken</em>(), replace 1 line</div>
<p>In the center, you have the new code to add. It may have a few faded out lines
above or below to show where it goes in the existing surrounding code. There is
also a little blurb telling you in which file and where to place the snippet. If
that blurb says &ldquo;replace _ lines&rdquo;, there is some existing code between the faded
lines that you need to remove and replace with the new snippet.</p>
<h3><a href="#asides" name="asides"><small>1&#8202;.&#8202;2&#8202;.&#8202;3</small>Asides</a></h3>
<p><span name="joke">Asides</span> contain biographical sketches, historical
background, references to related topics, and suggestions of other areas to
explore. There&rsquo;s nothing that you <em>need</em> to know in them to understand later
parts of the book, so you can skip them if you want. I won&rsquo;t judge you, but I
might be a little sad.</p>
<aside name="joke">
<p>Well, some asides do, at least. Most of them are just dumb jokes and amateurish
drawings.</p>
</aside>
<h3><a href="#challenges_" name="challenges_"><small>1&#8202;.&#8202;2&#8202;.&#8202;4</small>Challenges</a></h3>
<p>Each chapter ends with a few exercises. Unlike textbook problem sets, which tend
to review material you already covered, these are to help you learn <em>more</em> than
what&rsquo;s in the chapter. They force you to step off the guided path and explore on
your own. They will make you research other languages, figure out how to
implement features, or otherwise get you out of your comfort zone.</p>
<p><span name="warning">Vanquish</span> the challenges and you&rsquo;ll come away with a
broader understanding and possibly a few bumps and scrapes. Or skip them if you
want to stay inside the comfy confines of the tour bus. It&rsquo;s your book.</p>
<aside name="warning">
<p>A word of warning: the challenges often ask you to make changes to the
interpreter you&rsquo;re building. You&rsquo;ll want to implement those in a copy of your
code. The later chapters assume your interpreter is in a pristine
(&ldquo;unchallenged&rdquo;?) state.</p>
</aside>
<h3><a href="#design-notes" name="design-notes"><small>1&#8202;.&#8202;2&#8202;.&#8202;5</small>Design notes</a></h3>
<p>Most &ldquo;programming language&rdquo; books are strictly programming language
<em>implementation</em> books. They rarely discuss how one might happen to <em>design</em> the
language being implemented. Implementation is fun because it is so <span
name="benchmark">precisely defined</span>. We programmers seem to have an
affinity for things that are black and white, ones and zeroes.</p>
<aside name="benchmark">
<p>I know a lot of language hackers whose careers are based on this. You slide a
language spec under their door, wait a few months, and code and benchmark
results come out.</p>
</aside>
<p>Personally, I think the world needs only so many implementations of <span
name="fortran">FORTRAN 77</span>. At some point, you find yourself designing a
<em>new</em> language. Once you start playing <em>that</em> game, then the softer, human side
of the equation becomes paramount. Things like which features are easy to learn,
how to balance innovation and familiarity, what syntax is more readable and to
whom.</p>
<aside name="fortran">
<p>Hopefully your new language doesn&rsquo;t hardcode assumptions about the width of a
punched card into its grammar.</p>
</aside>
<p>All of that stuff profoundly affects the success of your new language. I want
your language to succeed, so in some chapters I end with a &ldquo;design note&rdquo;, a
little essay on some corner of the human aspect of programming languages. I&rsquo;m no
expert on this<span class="em">&mdash;</span>I don&rsquo;t know if anyone really is<span class="em">&mdash;</span>so take these with a large
pinch of salt. That should make them tastier food for thought, which is my main
aim.</p>
<h2><a href="#the-first-interpreter" name="the-first-interpreter"><small>1&#8202;.&#8202;3</small>The First Interpreter</a></h2>
<p>We&rsquo;ll write our first interpreter, jlox, in <span name="lang">Java</span>. The
focus is on <em>concepts</em>. We&rsquo;ll write the simplest, cleanest code we can to
correctly implement the semantics of the language. This will get us comfortable
with the basic techniques and also hone our understanding of exactly how the
language is supposed to behave.</p>
<aside name="lang">
<p>The book uses Java and C, but readers have ported the code to <a href="https://github.com/munificent/craftinginterpreters/wiki/Lox-implementations">many other
languages</a>. If the languages I picked aren&rsquo;t your bag, take a look at
those.</p>
</aside>
<p>Java is a great language for this. It&rsquo;s high level enough that we don&rsquo;t get
overwhelmed by fiddly implementation details, but it&rsquo;s still pretty explicit.
Unlike in scripting languages, there tends to be less complex machinery hiding
under the hood, and you&rsquo;ve got static types to see what data structures you&rsquo;re
working with.</p>
<p>I also chose Java specifically because it is an object-oriented language. That
paradigm swept the programming world in the &rsquo;90s and is now the dominant way of
thinking for millions of programmers. Odds are good you&rsquo;re already used to
organizing code into classes and methods, so we&rsquo;ll keep you in that comfort
zone.</p>
<p>While academic language folks sometimes look down on object-oriented languages,
the reality is that they are widely used even for language work. GCC and LLVM
are written in C++, as are most JavaScript virtual machines. Object-oriented
languages are ubiquitous, and the tools and compilers <em>for</em> a language are often
written <em>in</em> the <span name="host">same language</span>.</p>
<aside name="host">
<p>A compiler reads files in one language, translates them, and outputs files in
another language. You can implement a compiler in any language, including the
same language it compiles, a process called <strong>&ldquo;self-hosting&rdquo;</strong>.</p>
<p>You can&rsquo;t compile your compiler using itself yet, but if you have another
compiler for your language written in some other language, you use <em>that</em> one to
compile your compiler once. Now you can use the compiled version of your own
compiler to compile future versions of itself, and you can discard the original
one compiled from the other compiler. This is called <strong>&ldquo;bootstrapping&rdquo;</strong>, from
the image of pulling yourself up by your own bootstraps.</p><img src="image/introduction/bootstrap.png" alt="Fact: This is the primary mode of transportation of the American cowboy.">
</aside>
<p>And, finally, Java is hugely popular. That means there&rsquo;s a good chance you
already know it, so there&rsquo;s less for you to learn to get going in the book. If
you aren&rsquo;t that familiar with Java, don&rsquo;t freak out. I try to stick to a fairly
minimal subset of it. I use the diamond operator from Java 7 to make things a
little more terse, but that&rsquo;s about it as far as &ldquo;advanced&rdquo; features go. If you
know another object-oriented language, like C# or C++, you can muddle through.</p>
<p>By the end of part II, we&rsquo;ll have a simple, readable implementation. It&rsquo;s not
very fast, but it&rsquo;s correct. However, it work by taking advantage of the Java
virtual machine&rsquo;s own runtime facilities. We want to learn how Java <em>itself</em>
implements those things.</p>
<h2><a href="#the-second-interpreter" name="the-second-interpreter"><small>1&#8202;.&#8202;4</small>The Second Interpreter</a></h2>
<p>So in the next part, we start all over again, but this time in C. C is the
perfect language for understanding how an implementation <em>really</em> works, all the
way down to the bytes in memory and the code flowing through the CPU.</p>
<p>A big reason that we&rsquo;re using C is so I can show you things C is particularly
good at, but that <em>does</em> mean you&rsquo;ll need to be pretty comfortable with it. You
don&rsquo;t have to be the reincarnation of Dennis Ritchie, but you shouldn&rsquo;t be
spooked by pointers either.</p>
<p>If you aren&rsquo;t there yet, pick up an introductory book on C and chew through it,
then come back here when you&rsquo;re done. In return, you&rsquo;ll come away from this book
an even stronger C programmer. That&rsquo;s useful given how many language
implementations are written in C: Lua, CPython, and Ruby&rsquo;s MRI, to name a few.</p>
<p>In our C interpreter, <span name="clox">clox</span>, we are forced to implement
for ourselves all the things Java gave us for free. We&rsquo;ll write our own dynamic
array and hash table. We&rsquo;ll decide how objects are represented in memory, and
build a garbage collector to reclaim them.</p>
<aside name="clox">
<p>I pronounce the name like &ldquo;sea-locks&rdquo;, but you can say it &ldquo;clocks&rdquo; or even
&ldquo;clochs&rdquo;, where you pronounce the &ldquo;x&rdquo; like the Greeks do if it makes you happy.</p>
</aside>
<p>Our Java implementation was focused on being correct. Now that we have that
down, we&rsquo;ll turn to also being <em>fast</em>. Our C interpreter will contain a <span
name="compiler">compiler</span> that translates Lox to an efficient bytecode
representation (don&rsquo;t worry, I&rsquo;ll get into what that means soon), which it then
executes. This is the same technique used by implementations of Lua, Python,
Ruby, PHP, and many other successful languages.</p>
<aside name="compiler">
<p>Did you think this was just an interpreter book? It&rsquo;s a compiler book as well.
Two for the price of one!</p>
</aside>
<p>We&rsquo;ll even try our hand at benchmarking and optimization. By the end, we&rsquo;ll have
a robust, accurate, fast interpreter for our language, able to keep up with
other professional caliber implementations out there. Not bad for one book and a
few thousand lines of code.</p>
<div class="challenges">
<h2><a href="#challenges" name="challenges">Challenges</a></h2>
<ol>
<li>
<p>There are at least six domain-specific languages used in the <a href="https://github.com/munificent/craftinginterpreters">little system
I cobbled together</a> to write and publish this book. What are they?</p>
</li>
<li>
<p>Get a &ldquo;Hello, world!&rdquo; program written and running in Java. Set up whatever
makefiles or IDE projects you need to get it working. If you have a
debugger, get comfortable with it and step through your program as it runs.</p>
</li>
<li>
<p>Do the same thing for C. To get some practice with pointers, define a
<a href="https://en.wikipedia.org/wiki/Doubly_linked_list">doubly linked list</a> of heap-allocated strings. Write functions to insert,
find, and delete items from it. Test them.</p>
</li>
</ol>
</div>
<div class="design-note">
<h2><a href="#design-note" name="design-note">语言设计笔记: What&rsquo;s in a Name?</a></h2>
<p>One of the hardest challenges in writing this book was coming up with a name for
the language it implements. I went through <em>pages</em> of candidates before I found
one that worked. As you&rsquo;ll discover on the first day you start building your own
language, naming is deviously hard. A good name satisfies a few criteria:</p>
<ol>
<li>
<p><strong>It isn&rsquo;t in use.</strong> You can run into all sorts of trouble, legal and
social, if you inadvertently step on someone else&rsquo;s name.</p>
</li>
<li>
<p><strong>It&rsquo;s easy to pronounce.</strong> If things go well, hordes of people will be
saying and writing your language&rsquo;s name. Anything longer than a couple of
syllables or a handful of letters will annoy them to no end.</p>
</li>
<li>
<p><strong>It&rsquo;s distinct enough to search for.</strong> People will Google your language&rsquo;s
name to learn about it, so you want a word that&rsquo;s rare enough that most
results point to your docs. Though, with the amount of AI search engines are
packing today, that&rsquo;s less of an issue. Still, you won&rsquo;t be doing your users
any favors if you name your language &ldquo;for&rdquo;.</p>
</li>
<li>
<p><strong>It doesn&rsquo;t have negative connotations across a number of cultures.</strong> This
is hard to be on guard for, but it&rsquo;s worth considering. The designer of
Nimrod ended up renaming his language to &ldquo;Nim&rdquo; because too many people
remember that Bugs Bunny used &ldquo;Nimrod&rdquo; as an insult. (Bugs was using it
ironically.)</p>
</li>
</ol>
<p>If your potential name makes it through that gauntlet, keep it. Don&rsquo;t get hung
up on trying to find an appellation that captures the quintessence of your
language. If the names of the world&rsquo;s other successful languages teach us
anything, it&rsquo;s that the name doesn&rsquo;t matter much. All you need is a reasonably
unique token.</p>
</div>

<footer>
<a href="a-map-of-the-territory.html" class="next">
  下一章: &ldquo;全书导航&rdquo; &rarr;
</a>
Robert Nystrom 著  左元 译&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2020</a>
</footer>
</article>

</div>
</body>
</html>
