<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>A Map of the Territory &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype-small.png" title="Crafting Interpreters"></a>
  <div class="contents">
<!-- If there is a part, it must be a chapter within a part. -->
<h3><a href="#top">A Map of the Territory<small>2</small></a></h3>

<ul>
    <li><a href="#语言的各个部分"><small>2.1</small> 语言的各个部分</a></li>
    <li><a href="#shortcuts-and-alternate-routes"><small>2.2</small> Shortcuts and Alternate Routes</a></li>
    <li><a href="#编译器和解释器"><small>2.3</small> 编译器和解释器</a></li>
    <li><a href="#我们的旅程"><small>2.4</small> 我们的旅程</a></li>
    <li><a href="#挑战"><small>2.5</small> 挑战</a></li>
</ul>


<div class="prev-next">
    <a href="introduction.html" title="Introduction" class="left">&larr;&nbsp;Previous</a>
    <a href="welcome.html" title="Welcome">&uarr;&nbsp;Up</a>
    <a href="the-lox-language.html" title="The Lox Language" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype-small.png" title="Crafting Interpreters"></a>
<a href="introduction.html" title="Introduction" class="prev">←</a>
<a href="the-lox-language.html" title="The Lox Language" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype-small.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<!-- If there is a part, it must be a chapter within a part. -->
<h3><a href="#top">A Map of the Territory<small>2</small></a></h3>

<ul>
    <li><a href="#语言的各个部分"><small>2.1</small> 语言的各个部分</a></li>
    <li><a href="#shortcuts-and-alternate-routes"><small>2.2</small> Shortcuts and Alternate Routes</a></li>
    <li><a href="#编译器和解释器"><small>2.3</small> 编译器和解释器</a></li>
    <li><a href="#我们的旅程"><small>2.4</small> 我们的旅程</a></li>
    <li><a href="#挑战"><small>2.5</small> 挑战</a></li>
</ul>


<div class="prev-next">
    <a href="introduction.html" title="Introduction" class="left">&larr;&nbsp;Previous</a>
    <a href="welcome.html" title="Welcome">&uarr;&nbsp;Up</a>
    <a href="the-lox-language.html" title="The Lox Language" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">2</div>
  <h1>A Map of the Territory</h1>

<blockquote>
<p>你必须拥有一幅地图，无论这幅地图多么粗糙。否则你可能得把整个地方都走一遍。在<em>指环王</em>中，我不会让任何一个人走的距离超过他一天之内能走到的地方。</p>
<p><cite>托尔金</cite></p>
</blockquote>
<p>我们不想把所有地方都走一遍，所以在出发之前，我们先来看一下扫描一下，看看曾经的语言实现者们都去过哪些地方。这样将会帮助我们认识我们将要去的地方，以及其他人所选择的路线是什么。</p>
<p>首先，让我来做一个速记。本书大部分内容是关于编程语言的<em>实现</em>，在某种程度上与<em>语言本身</em>不同，<em>语言本身</em>有点像柏拉图的理想形式这一概念。诸如“堆栈”，“字节码”和“递归下降”之类的东西，是一种特定实现可能使用的一些基本要素。从用户的角度来看，只要我们解释器的实现忠实地遵循语言的规范，那么所有的基本要素，全部是实现细节。</p>
<p>我们将会在细节上面花费大量的时间，所以如果每次我在提到这些细节时，都必须提到“语言<em>实现</em>”这个词，那我的手指头会抽筋儿。所以，我会使用“语言”这个词来表达一门语言或者这门语言的实现这两种含义，除非上下文要求我做出这两种意思的区别。</p>
<h2><a href="#语言的各个部分" name="语言的各个部分"><small>2&#8202;.&#8202;1</small>语言的各个部分</a></h2>
<p>工程师从计算的暗黑时代就开始构建编程语言了。当我们能和计算机对话时，我们会发现和计算机对话是一件非常困难的事情，所以我们需要借助编程语言来和计算机对话。我发现一件很有意思的事情，就是虽然当今的计算机比最开始的计算机已经快了几百万倍，存储空间也大了很多很多，但我们构建编程语言的方式几乎没有改变。</p>
<p>尽管编程语言设计者们所探索的领域非常的庞大，但他们走过的路线却<span name="dead">非常少</span>。虽然不是每一个编程语言的实现都遵循着完全一样的路径——一些语言可能会走一些捷径——但这些路径是非常非常相似的。从霍普实现的第一个COBOL语言的编译器到现在很多将一门语言直接编译到JavaScript的编译器（可能非常的简陋，整个文档只是一个简单编写的Github上的README），所遵循的路径都是差不多的。</p>
<aside name="dead">
<p>有些路径已经走到了死胡同，比如那些零引用的论文，那些只在内存只有几百个字节情况下才有意义的优化。这些成果现在已经都被遗忘了。</p>
</aside>
<p>可以打个比方，这些路径都是每一个编程语言的实现所选择的登上山顶的路线而已。在山脚下从山的左边开始登山时，我们写的代码可能仅仅是字符串所构成的原始文本（比如<code>helloworld.java</code>），慢慢的往上爬，我们分析写的代码然后将这些代码转化成更高层次的表示（抽象语法树AST之类的），随着爬的越来越高，语义——也就是程序员想让计算机做的事情——变得越来越明显和清晰。</p>
<p>我们终于爬到了山顶。这时我们可以鸟瞰我们编写的整个程序，也能看到这些代码的真正<em>含义</em>。接下来我们从山的右边开始下山。我们将代码的高层次表示转换成底层表示形式，到了最底层我们终于可以看到CPU是如何执行这些代码的。</p><img src="image/a-map-of-the-territory/mountain.png" alt="The branching paths a language may take over the mountain." class="wide" />
<p>让我们来跟踪一下感兴趣的路径以及路径上有意思的每一个点。我们的旅程从山的左侧开始往山上爬，也就是从用户写的源程序的文本开始。</p><img src="image/a-map-of-the-territory/string.png" alt="var average = (min + max) / 2;" />
<h3><a href="#扫描" name="扫描"><small>2&#8202;.&#8202;1&#8202;.&#8202;1</small>扫描</a></h3>
<p>第一步是进行<strong>扫描（scan）</strong>，如果你想装叉，也可以叫<strong>词法分析（lexing）</strong>。它们的意思都差不多。我喜欢“词法分析”这个词，因为这个就像是超级恶棍才会去做的事情。但这里我会使用“扫描”这个词，因为这个词会显得普通一些。</p>
<p>一个<strong>扫描器（scanner）</strong>（或者<strong>词法分析器（lexer）</strong>）会把源程序的文本当成字符流一个字符一个字符的读进来。然后，将字符流转换成一系列的<span name="word">单词</span>。在编程语言里，每一个单词都叫做一个<strong>token</strong>。某一些token是单个字符，例如<code>(</code>和<code>,</code>。另一些token会由多个字符组成，例如数字（<code>123</code>），字符串的字面量（<code>"hi!"</code>），以及标识符（变量名，函数名等等都是标识符，比如<code>min</code>）等等。</p>
<aside name="word">
<p>“Lexical”这个词来自希腊语词根“lex”，意思是“单词”。</p>
</aside>
<p>源程序文件中有一些字符是没有任何含义的。比如空格通常情况下完全不重要（除了Python这种强制缩进的语言），而注释也会被语言彻底忽略掉。所以扫描器一般会将空格和注释都丢弃掉，然后剩下一个干净的有意义的token序列。</p><img src="image/a-map-of-the-territory/tokens.png" alt="[var] [average] [=] [(] [min] [+] [max] [)] [/] [2] [;]" />
<h3><a href="#解析" name="解析"><small>2&#8202;.&#8202;1&#8202;.&#8202;2</small>解析</a></h3>
<p>接下来的这一步是<strong>解析（parsing）</strong>。这里是我们的句法（syntax）得到一个<strong>语法（grammar）</strong>——从较小的部分构建更大的表达式和语句的能力就是语法——的地方。你在英语课堂上给一个句子标过语法成分（主语、谓语、宾语）吗？如果你标过，那你已经做过解析器要做的事情了。只不过英文中有着成千上万个“关键字”，而且语言的歧义已经爆表。编程语言相对于自然语言来说要简单得多（也不允许有歧义）。</p>
<p>一个<strong>解析器</strong>会接收一个token序列，然后构造一个树形结构，这个树形结构反映了语法的嵌套本质。这些树形结构有各种不同的名字——<strong>解析树</strong>或者<strong>抽象语法树</strong>——具体叫什么取决于树形结构和源程序所使用的语言的语法结构的相近程度。在实践中，编程语言黑客们通常叫这些树形结构为<strong>语法树</strong>，<strong>抽象语法树（AST）<strong>或者就叫它们</strong>树</strong>。</p><img src="image/a-map-of-the-territory/ast.png" alt="An abstract syntax tree." />
<p>在计算机科学的历史上，解析技术有着长长的丰富的历史。并且解析技术和人工智能社区有着非常紧密的联系。今天所使用的用来解析编程语言的很多解析技术，最开始都是AI研究者为了解析<em>自然语言</em>而发明的。这些AI研究者想让计算机和我们进行对话。</p>
<p>结果发现人类所使用的自然语言太过于复杂和混乱，而解析器的技术只能处理严格的语法。但这些解析器技术却非常适合用来解析编程语言的语法，因为编程语言有着非常严格的无歧义的语法定义。编程语言的语法虽然比自然语言简单多了，但我们这些容易犯错的人类在写代码时还是不断的犯各种错误，所以解析器的任务还包括报告我们编写的代码里面的<strong>语法错误</strong>。</p>
<h3><a href="#静态分析" name="静态分析"><small>2&#8202;.&#8202;1&#8202;.&#8202;3</small>静态分析</a></h3>
<p>所有编程语言的实现的前两个阶段（扫描和解析）都是非常相似的。接下来，每个编程语言的实现的独特特点就开始展现了。在现在这个节点（做完扫描和解析之后），我们仅仅知道代码的语法结构——比如表达式是如何嵌套的这样一些信息——除此以外，我们一无所知。</p>
<p>在表达式<code>a + b</code>中，我们知道我们要对<code>a</code>和<code>b</code>进行相加，但我们并不知道<code>a</code>和<code>b</code>具体指的是什么。它们是局部变量吗？还是全局变量？它们在哪里定义的？</p>
<p>对于多数编程语言来说，我们要分析的第一点就是<strong>绑定（binding）<strong>或者</strong>决议（resolution）</strong>。对于每一个<strong>标识符（identifier）</strong>，我们需要找出这个标识符在哪里定义的，然后将这个标识符和它所定义的地方连接起来。这里就是**作用域（scope）**要玩耍的地方——每一个确定的名字（变量名，函数名之类的）在代码中都会有相应的明确的定义，这个定义所谓于的源程序中的那个区域就是作用域。</p>
<p>如果一个语言是<span name="type">静态类型的</span>，那当我们在做类型检查的时候就是在做静态分析。一旦我们知道<code>a</code>和<code>b</code>在哪里定义的，我们很容易就可以确定它们的类型。如果<code>a</code>和<code>b</code>的类型是无法相加的（整型和字符串型就不可以相加），那么我们就可以报告一个<strong>类型错误</strong>。</p>
<aside name="type">
<p>我们要构建的语言Lox是一个动态类型的语言，所以我们会在后面的步骤中做类型检查，也就是在运行时（runtime）才做类型检查。</p>
</aside>
<p>深呼吸一下。我们已经到达了山顶，并对我们写的代码有了一个全景式的俯瞰。在静态分析中所得到的对程序语义的洞见，需要保存起来。我们可以将这些东西保存在下面列出的这些地方：</p>
<ul>
<li>
<p>通常情况下，我们会把这些语义信息作为语法树本身的<strong>属性</strong>保存起来——也就是说我们在使用解析器构建语法树时，为语法树的每一个节点都留了一些空位（把后面要用到的属性赋值为null），然后在静态分析这一步，把语义信息添加到这些空位中去。</p>
</li>
<li>
<p>还有一些情况下，我们可以把这些语义信息存放在查找表（lookup table）中，查找表可以用Hashmap来实现。查找表中的key是标识符——变量名或者函数声明。这种情况下，我们叫这个查找表为<strong>符号表（symbol table）</strong>，而查找表中的key所对应的value告诉了我们key具体的定义是什么。</p>
</li>
<li>
<p>最为强大的语义信息的记录工具，则是将抽象语法树转换为一个全新的数据结构，这个数据结构可以更加直接的表示代码的语义信息。下一部分就是讲这个内容。</p>
</li>
</ul>
<p>到目前为止（词法分析，语法分析，语义分析），这三个阶段通常叫做解释器实现的<strong>前端</strong>。你可能觉得后面的阶段都是<strong>后端</strong>，不是这样的。回到过去那种只有“前端”和“后端”这两种概念的日子时，编译器比现在简单多了。后来的研究者在“前端”和“后端”的中间又发明了新的阶段。威廉·伍尔夫和他的公司并没有抛弃掉那些旧的术语，而是将他们发明的那些新的阶段统称为<strong>中端</strong>。</p>
<h3><a href="#中间表示" name="中间表示"><small>2&#8202;.&#8202;1&#8202;.&#8202;4</small>中间表示</a></h3>
<p>你可以把编译器想像成一条流水线，流水线的每一个阶段的工作就是将用户写的代码组织成某种数据表示，这种数据表示使得流水线的下一个阶段更加容易实现。流水线的前端主要关心编写程序所用的编程语言。流水线的后端则更加关心程序最终将要运行在的那个体系结构。</p>
<p>在中端，代码可能会以<span name="ir"><strong>中间表示（intermediate representation）</strong></span>（<strong>IR</strong>）的形式来存储。这种形式既不贴近源语言，也不贴近像汇编语言这样的最终形式（所以叫中间表示）。实际上，IR相当于两种语言（源语言和汇编语言）中间的接口。</p>
<aside name="ir">
<p>前人已经构建过很多种IR。你可以搜索一下“控制流图（control flow graph）”、“静态单赋值（static single-assignment）”、“CPS（continuation-passing style）”以及“三地址码（three-address code）”等等，都是很著名的IR。</p>
</aside>
<p>This lets you support multiple source languages and target platforms with less
effort. Say you want to implement Pascal, C, and Fortran compilers, and you want
to target x86, ARM, and, I dunno, SPARC. Normally, that means you&rsquo;re signing up
to write <em>nine</em> full compilers: Pascal&rarr;x86, C&rarr;ARM, and every other
combination.</p>
<p>有了IR，我们不用费太多力气，就可以支持很多的编程语言以及很多的目标平台。比如你现在想实现Pascal，C和Fortran编译器，你可能想把这些语言编译到x86，ARM或许还有SPARC这种罕见的平台。这意味着你需要写<em>9</em>个完整的编译器：Pascal&rarr;x86, C&rarr;ARM, 以及其他排列组合。</p>
<p>而一个<span name="gcc">共享的</span>中间表示（IR），将会大幅度减小我们的工作量。你只需要为每一门编程语言写<em>一个</em>前端，这个前端用来把源程序编译成IR。然后再为每一个目标体系结构写<em>一个</em>后端就可以了，这个后端将IR编译成目标机器的汇编语言。这样我们就可以实现上述那么多排列组合了。</p>
<aside name="gcc">
<p>你现在应该知道为什么<a href="https://en.wikipedia.org/wiki/GNU_Compiler_Collection">GCC</a>支持这么多疯狂的语言和体系结构了吧，比如像摩托罗拉68k上面的Modula-3语言的编译器（语言和体系结构都很冷门）。编程语言的前端可以选择编译成众多的IR，通常会选<a href="https://gcc.gnu.org/onlinedocs/gccint/GIMPLE.html">GIMPLE</a>和<a href="https://gcc.gnu.org/onlinedocs/gccint/RTL.html">RTL</a>这两种IR。然后可以选择一个目标为68k体系结构的后端，这样就可以把IR转换成平台相关的机器代码了。</p>
</aside>
<p>还有一个重要的原因使得我们想把代码转换成IR，就是IR会使程序的语义变得更加清晰和明显。</p>
<h3><a href="#优化" name="优化"><small>2&#8202;.&#8202;1&#8202;.&#8202;5</small>优化</a></h3>
<p>Once we understand what the user&rsquo;s program means, we are free to swap it out
with a different program that has the <em>same semantics</em> but implements them more
efficiently<span class="em">&mdash;</span>we can <strong>optimize</strong> it.</p>
<p>A simple example is <strong>constant folding</strong>: if some expression always evaluates to
the exact same value, we can do the evaluation at compile time and replace the
code for the expression with its result. If the user typed in this:</p>
<div class="codehilite"><pre>
<span class="i">pennyArea</span> = <span class="n">3.14159</span> * (<span class="n">0.75</span> / <span class="n">2</span>) * (<span class="n">0.75</span> / <span class="n">2</span>);
</pre></div>
<p>we could do all of that arithmetic in the compiler and change the code to:</p>
<div class="codehilite"><pre>
<span class="i">pennyArea</span> = <span class="n">0.4417860938</span>;
</pre></div>
<p>Optimization is a huge part of the programming language business. Many language
hackers spend their entire careers here, squeezing every drop of performance
they can out of their compilers to get their benchmarks a fraction of a percent
faster. It can become a sort of obsession.</p>
<p>We&rsquo;re mostly going to <span name="rathole">hop over that rathole</span> in this
book. Many successful languages have surprisingly few compile-time
optimizations. For example, Lua and CPython generate relatively unoptimized
code, and focus most of their performance effort on the runtime.</p>
<aside name="rathole">
<p>If you can&rsquo;t resist poking your foot into that hole, some keywords to get you
started are &ldquo;constant propagation&rdquo;, &ldquo;common subexpression elimination&rdquo;, &ldquo;loop
invariant code motion&rdquo;, &ldquo;global value numbering&rdquo;, &ldquo;strength reduction&rdquo;, &ldquo;scalar
replacement of aggregates&rdquo;, &ldquo;dead code elimination&rdquo;, and &ldquo;loop unrolling&rdquo;.</p>
</aside>
<h3><a href="#代码生成" name="代码生成"><small>2&#8202;.&#8202;1&#8202;.&#8202;6</small>代码生成</a></h3>
<p>We have applied all of the optimizations we can think of to the user&rsquo;s program.
The last step is converting it to a form the machine can actually run. In other
words, <strong>generating code</strong> (or <strong>code gen</strong>), where &ldquo;code&rdquo; here usually refers to
the kind of primitive assembly-like instructions a CPU runs and not the kind of
&ldquo;source code&rdquo; a human might want to read.</p>
<p>Finally, we are in the <strong>back end</strong>, descending the other side of the mountain.
From here on out, our representation of the code becomes more and more
primitive, like evolution run in reverse, as we get closer to something our
simple-minded machine can understand.</p>
<p>We have a decision to make. Do we generate instructions for a real CPU or a
virtual one? If we generate real machine code, we get an executable that the OS
can load directly onto the chip. Native code is lightning fast, but generating
it is a lot of work. Today&rsquo;s architectures have piles of instructions, complex
pipelines, and enough <span name="aad">historical baggage</span> to fill a 747&rsquo;s
luggage bay.</p>
<p>Speaking the chip&rsquo;s language also means your compiler is tied to a specific
architecture. If your compiler targets <a href="https://en.wikipedia.org/wiki/X86">x86</a> machine code, it&rsquo;s not going to
run on an <a href="https://en.wikipedia.org/wiki/ARM_architecture">ARM</a> device. All the way back in the &rsquo;60s, during the
Cambrian explosion of computer architectures, that lack of portability was a
real obstacle.</p>
<aside name="aad">
<p>For example, the <a href="http://www.felixcloutier.com/x86/AAD.html">AAD</a> (&ldquo;ASCII Adjust AX Before Division&rdquo;) instruction lets
you perform division, which sounds useful. Except that instruction takes, as
operands, two binary-coded decimal digits packed into a single 16-bit register.
When was the last time <em>you</em> needed BCD on a 16-bit machine?</p>
</aside>
<p>To get around that, hackers like Martin Richards and Niklaus Wirth, of BCPL and
Pascal fame, respectively, made their compilers produce <em>virtual</em> machine code.
Instead of instructions for some real chip, they produced code for a
hypothetical, idealized machine. Wirth called this <strong>p-code</strong> for <em>portable</em>,
but today, we generally call it <strong>bytecode</strong> because each instruction is often a
single byte long.</p>
<p>These synthetic instructions are designed to map a little more closely to the
language&rsquo;s semantics, and not be so tied to the peculiarities of any one
computer architecture and its accumulated historical cruft. You can think of it
like a dense, binary encoding of the language&rsquo;s low-level operations.</p>
<h3><a href="#虚拟机" name="虚拟机"><small>2&#8202;.&#8202;1&#8202;.&#8202;7</small>虚拟机</a></h3>
<p>If your compiler produces bytecode, your work isn&rsquo;t over once that&rsquo;s done. Since
there is no chip that speaks that bytecode, it&rsquo;s your job to translate. Again,
you have two options. You can write a little mini-compiler for each target
architecture that converts the bytecode to native code for that machine. You
still have to do work for <span name="shared">each</span> chip you support, but
this last stage is pretty simple and you get to reuse the rest of the compiler
pipeline across all of the machines you support. You&rsquo;re basically using your
bytecode as an intermediate representation.</p>
<aside name="shared" class="bottom">
<p>The basic principle here is that the farther down the pipeline you push the
architecture-specific work, the more of the earlier phases you can share across
architectures.</p>
<p>There is a tension, though. Many optimizations, like register allocation and
instruction selection, work best when they know the strengths and capabilities
of a specific chip. Figuring out which parts of your compiler can be shared and
which should be target-specific is an art.</p>
</aside>
<p>Or you can write a <span name="vm"><strong>virtual machine</strong></span> (<strong>VM</strong>), a
program that emulates a hypothetical chip supporting your virtual architecture
at runtime. Running bytecode in a VM is slower than translating it to native
code ahead of time because every instruction must be simulated at runtime each
time it executes. In return, you get simplicity and portability. Implement your
VM in, say, C, and you can run your language on any platform that has a C
compiler. This is how the second interpreter we build in this book works.</p>
<aside name="vm">
<p>The term &ldquo;virtual machine&rdquo; also refers to a different kind of abstraction. A
<strong>system virtual machine</strong> emulates an entire hardware platform and operating
system in software. This is how you can play Windows games on your Linux
machine, and how cloud providers give customers the user experience of
controlling their own &ldquo;server&rdquo; without needing to physically allocate separate
computers for each user.</p>
<p>The kind of VMs we&rsquo;ll talk about in this book are <strong>language virtual machines</strong>
or <strong>process virtual machines</strong> if you want to be unambiguous.</p>
</aside>
<h3><a href="#运行时" name="运行时"><small>2&#8202;.&#8202;1&#8202;.&#8202;8</small>运行时</a></h3>
<p>We have finally hammered the user&rsquo;s program into a form that we can execute. The
last step is running it. If we compiled it to machine code, we simply tell the
operating system to load the executable and off it goes. If we compiled it to
bytecode, we need to start up the VM and load the program into that.</p>
<p>In both cases, for all but the basest of low-level languages, we usually need
some services that our language provides while the program is running. For
example, if the language automatically manages memory, we need a garbage
collector going in order to reclaim unused bits. If our language supports
&ldquo;instance of&rdquo; tests so you can see what kind of object you have, then we need
some representation to keep track of the type of each object during execution.</p>
<p>All of this stuff is going at runtime, so it&rsquo;s called, appropriately, the
<strong>runtime</strong>. In a fully compiled language, the code implementing the runtime
gets inserted directly into the resulting executable. In, say, <a href="https://golang.org/">Go</a>, each
compiled application has its own copy of Go&rsquo;s runtime directly embedded in it.
If the language is run inside an interpreter or VM, then the runtime lives
there. This is how most implementations of languages like Java, Python, and
JavaScript work.</p>
<h2><a href="#shortcuts-and-alternate-routes" name="shortcuts-and-alternate-routes"><small>2&#8202;.&#8202;2</small>Shortcuts and Alternate Routes</a></h2>
<p>That&rsquo;s the long path covering every possible phase you might implement. Many
languages do walk the entire route, but there are a few shortcuts and alternate
paths.</p>
<h3><a href="#单趟编译器" name="单趟编译器"><small>2&#8202;.&#8202;2&#8202;.&#8202;1</small>单趟编译器</a></h3>
<p>Some simple compilers interleave parsing, analysis, and code generation so that
they produce output code directly in the parser, without ever allocating any
syntax trees or other IRs. These <span name="sdt"><strong>single-pass
compilers</strong></span> restrict the design of the language. You have no intermediate
data structures to store global information about the program, and you don&rsquo;t
revisit any previously parsed part of the code. That means as soon as you see
some expression, you need to know enough to correctly compile it.</p>
<aside name="sdt">
<p><a href="https://en.wikipedia.org/wiki/Syntax-directed_translation"><strong>Syntax-directed translation</strong></a> is a structured technique for building
these all-at-once compilers. You associate an <em>action</em> with each piece of the
grammar, usually one that generates output code. Then, whenever the parser
matches that chunk of syntax, it executes the action, building up the target
code one rule at a time.</p>
</aside>
<p>Pascal and C were designed around this limitation. At the time, memory was so
precious that a compiler might not even be able to hold an entire <em>source file</em>
in memory, much less the whole program. This is why Pascal&rsquo;s grammar requires
type declarations to appear first in a block. It&rsquo;s why in C you can&rsquo;t call a
function above the code that defines it unless you have an explicit forward
declaration that tells the compiler what it needs to know to generate code for a
call to the later function.</p>
<h3><a href="#树遍历解释器" name="树遍历解释器"><small>2&#8202;.&#8202;2&#8202;.&#8202;2</small>树遍历解释器</a></h3>
<p>Some programming languages begin executing code right after parsing it to an AST
(with maybe a bit of static analysis applied). To run the program, the
interpreter traverses the syntax tree one branch and leaf at a time, evaluating
each node as it goes.</p>
<p>This implementation style is common for student projects and little languages,
but is not widely used for <span name="ruby">general-purpose</span> languages
since it tends to be slow. Some people use &ldquo;interpreter&rdquo; to mean only these
kinds of implementations, but others define that word more generally, so I&rsquo;ll
use the inarguably explicit <strong>&ldquo;tree-walk interpreter&rdquo;</strong> to refer to these. Our
first interpreter rolls this way.</p>
<aside name="ruby">
<p>A notable exception is early versions of Ruby, which were tree walkers. At 1.9,
the canonical implementation of Ruby switched from the original MRI (Matz&rsquo;s Ruby
Interpreter) to Koichi Sasada&rsquo;s YARV (Yet Another Ruby VM). YARV is a
bytecode virtual machine.</p>
</aside>
<h3><a href="#转译器" name="转译器"><small>2&#8202;.&#8202;2&#8202;.&#8202;3</small>转译器</a></h3>
<p><span name="gary">Writing</span> a complete back end for a language can be a lot
of work. If you have some existing generic IR to target, you could bolt your
front end onto that. Otherwise, it seems like you&rsquo;re stuck. But what if you
treated some other <em>source language</em> as if it were an intermediate
representation?</p>
<p>You write a front end for your language. Then, in the back end, instead of doing
all the work to <em>lower</em> the semantics to some primitive target language, you
produce a string of valid source code for some other language that&rsquo;s about as
high level as yours. Then, you use the existing compilation tools for <em>that</em>
language as your escape route off the mountain and down to something you can
execute.</p>
<p>They used to call this a <strong>source-to-source compiler</strong> or a <strong>transcompiler</strong>.
After the rise of languages that compile to JavaScript in order to run in the
browser, they&rsquo;ve affected the hipster sobriquet <strong>transpiler</strong>.</p>
<aside name="gary">
<p>The first transcompiler, XLT86, translated 8080 assembly into 8086 assembly.
That might seem straightforward, but keep in mind the 8080 was an 8-bit chip and
the 8086 a 16-bit chip that could use each register as a pair of 8-bit ones.
XLT86 did data flow analysis to track register usage in the source program and
then efficiently map it to the register set of the 8086.</p>
<p>It was written by Gary Kildall, a tragic hero of computer science if there
ever was one. One of the first people to recognize the promise of
microcomputers, he created PL/M and CP/M, the first high-level language and OS
for them.</p>
<p>He was a sea captain, business owner, licensed pilot, and motorcyclist. A TV
host with the Kris Kristofferson-esque look sported by dashing bearded dudes in
the &rsquo;80s. He took on Bill Gates and, like many, lost, before meeting his end in
a biker bar under mysterious circumstances. He died too young, but sure as hell
lived before he did.</p>
</aside>
<p>While the first transcompiler translated one assembly language to another,
today, most transpilers work on higher-level languages. After the viral spread
of UNIX to machines various and sundry, there began a long tradition of
compilers that produced C as their output language. C compilers were available
everywhere UNIX was and produced efficient code, so targeting C was a good way
to get your language running on a lot of architectures.</p>
<p>Web browsers are the &ldquo;machines&rdquo; of today, and their &ldquo;machine code&rdquo; is
JavaScript, so these days it seems <a href="https://github.com/jashkenas/coffeescript/wiki/list-of-languages-that-compile-to-js">almost every language out there</a> has a
compiler that targets JS since that&rsquo;s the <span name="js">main</span> way to get
your code running in a browser.</p>
<aside name="js">
<p>JS used to be the <em>only</em> way to execute code in a browser. Thanks to
<a href="https://github.com/webassembly/">WebAssembly</a>, compilers now have a second, lower-level language they can
target that runs on the web.</p>
</aside>
<p>The front end<span class="em">&mdash;</span>scanner and parser<span class="em">&mdash;</span>of a transpiler looks like other
compilers. Then, if the source language is only a simple syntactic skin over the
target language, it may skip analysis entirely and go straight to outputting the
analogous syntax in the destination language.</p>
<p>If the two languages are more semantically different, you&rsquo;ll see more of the
typical phases of a full compiler including analysis and possibly even
optimization. Then, when it comes to code generation, instead of outputting some
binary language like machine code, you produce a string of grammatically correct
source (well, destination) code in the target language.</p>
<p>Either way, you then run that resulting code through the output language&rsquo;s
existing compilation pipeline, and you&rsquo;re good to go.</p>
<h3><a href="#及时编译" name="及时编译"><small>2&#8202;.&#8202;2&#8202;.&#8202;4</small>及时编译</a></h3>
<p>This last one is less a shortcut and more a dangerous alpine scramble best
reserved for experts. The fastest way to execute code is by compiling it to
machine code, but you might not know what architecture your end user&rsquo;s machine
supports. What to do?</p>
<p>You can do the same thing that the HotSpot Java Virtual Machine (JVM),
Microsoft&rsquo;s Common Language Runtime (CLR), and most JavaScript interpreters do.
On the end user&rsquo;s machine, when the program is loaded<span class="em">&mdash;</span>either from source in
the case of JS, or platform-independent bytecode for the JVM and CLR<span class="em">&mdash;</span>you
compile it to native for the architecture their computer supports. Naturally
enough, this is called <strong>just-in-time compilation</strong>. Most hackers just say
&ldquo;JIT&rdquo;, pronounced like it rhymes with &ldquo;fit&rdquo;.</p>
<p>The most sophisticated JITs insert profiling hooks into the generated code to
see which regions are most performance critical and what kind of data is flowing
through them. Then, over time, they will automatically recompile those <span
name="hot">hot spots</span> with more advanced optimizations.</p>
<aside name="hot">
<p>This is, of course, exactly where the HotSpot JVM gets its name.</p>
</aside>
<h2><a href="#编译器和解释器" name="编译器和解释器"><small>2&#8202;.&#8202;3</small>编译器和解释器</a></h2>
<p>Now that I&rsquo;ve stuffed your head with a dictionary&rsquo;s worth of programming
language jargon, we can finally address a question that&rsquo;s plagued coders since
time immemorial: What&rsquo;s the difference between a compiler and an interpreter?</p>
<p>It turns out this is like asking the difference between a fruit and a vegetable.
That seems like a binary either-or choice, but actually &ldquo;fruit&rdquo; is a <em>botanical</em>
term and &ldquo;vegetable&rdquo; is <em>culinary</em>. One does not strictly imply the negation of
the other. There are fruits that aren&rsquo;t vegetables (apples) and vegetables that
aren&rsquo;t fruits (carrots), but also edible plants that are both fruits <em>and</em>
vegetables, like tomatoes.</p>
<p><span name="veg"></span></span></p><img src="image/a-map-of-the-territory/plants.png" alt="A Venn diagram of edible plants" />
<aside name="veg">
<p>Peanuts (which are not even nuts) and cereals like wheat are actually fruit, but
I got this drawing wrong. What can I say, I&rsquo;m a software engineer, not a
botanist. I should probably erase the little peanut guy, but he&rsquo;s so cute that I
can&rsquo;t bear to.</p>
<p>Now <em>pine nuts</em>, on the other hand, are plant-based foods that are neither
fruits nor vegetables. At least as far as I can tell.</p>
</aside>
<p>So, back to languages:</p>
<ul>
<li>
<p><strong>Compiling</strong> is an <em>implementation technique</em> that involves translating a
source language to some other<span class="em">&mdash;</span>usually lower-level<span class="em">&mdash;</span>form. When you
generate bytecode or machine code, you are compiling. When you transpile to
another high-level language, you are compiling too.</p>
</li>
<li>
<p>When we say a language implementation &ldquo;is a <strong>compiler</strong>&rdquo;, we mean it
translates source code to some other form but doesn&rsquo;t execute it. The user has
to take the resulting output and run it themselves.</p>
</li>
<li>
<p>Conversely, when we say an implementation &ldquo;is an <strong>interpreter</strong>&rdquo;, we mean it
takes in source code and executes it immediately. It runs programs &ldquo;from
source&rdquo;.</p>
</li>
</ul>
<p>Like apples and oranges, some implementations are clearly compilers and <em>not</em>
interpreters. GCC and Clang take your C code and compile it to machine code. An
end user runs that executable directly and may never even know which tool was
used to compile it. So those are <em>compilers</em> for C.</p>
<p>In older versions of Matz&rsquo;s canonical implementation of Ruby, the user ran Ruby
from source. The implementation parsed it and executed it directly by traversing
the syntax tree. No other translation occurred, either internally or in any
user-visible form. So this was definitely an <em>interpreter</em> for Ruby.</p>
<p>But what of CPython? When you run your Python program using it, the code is
parsed and converted to an internal bytecode format, which is then executed
inside the VM. From the user&rsquo;s perspective, this is clearly an interpreter<span class="em">&mdash;</span>they run their program from source. But if you look under CPython&rsquo;s scaly skin,
you&rsquo;ll see that there is definitely some compiling going on.</p>
<p>The answer is that it is <span name="go">both</span>. CPython <em>is</em> an
interpreter, and it <em>has</em> a compiler. In practice, most scripting languages work
this way, as you can see:</p>
<aside name="go">
<p>The <a href="https://golang.org/">Go tool</a> is even more of a horticultural curiosity. If you run <code>go build</code>, it compiles your Go source code to machine code and stops. If you type
<code>go run</code>, it does that, then immediately executes the generated executable.</p>
<p>So <code>go</code> <em>is</em> a compiler (you can use it as a tool to compile code without
running it), <em>is</em> an interpreter (you can invoke it to immediately run a program
from source), and also <em>has</em> a compiler (when you use it as an interpreter, it
is still compiling internally).</p>
</aside><img src="image/a-map-of-the-territory/venn.png" alt="A Venn diagram of compilers and interpreters" />
<p>That overlapping region in the center is where our second interpreter lives too,
since it internally compiles to bytecode. So while this book is nominally about
interpreters, we&rsquo;ll cover some compilation too.</p>
<h2><a href="#我们的旅程" name="我们的旅程"><small>2&#8202;.&#8202;4</small>我们的旅程</a></h2>
<p>That&rsquo;s a lot to take in all at once. Don&rsquo;t worry. This isn&rsquo;t the chapter where
you&rsquo;re expected to <em>understand</em> all of these pieces and parts. I just want you
to know that they are out there and roughly how they fit together.</p>
<p>This map should serve you well as you explore the territory beyond the guided
path we take in this book. I want to leave you yearning to strike out on your
own and wander all over that mountain.</p>
<p>But, for now, it&rsquo;s time for our own journey to begin. Tighten your bootlaces,
cinch up your pack, and come along. From <span name="here">here</span> on out,
all you need to focus on is the path in front of you.</p>
<aside name="here">
<p>Henceforth, I promise to tone down the whole mountain metaphor thing.</p>
</aside>
<div class="challenges">
<h2><a href="#挑战" name="挑战"><small>2&#8202;.&#8202;5</small>挑战</a></h2>
<ol>
<li>
<p>Pick an open source implementation of a language you like. Download the
source code and poke around in it. Try to find the code that implements the
scanner and parser. Are they handwritten, or generated using tools like
Lex and Yacc? (<code>.l</code> or <code>.y</code> files usually imply the latter.)</p>
</li>
<li>
<p>Just-in-time compilation tends to be the fastest way to implement dynamically
typed languages, but not all of them use it. What reasons are there to <em>not</em>
JIT?</p>
</li>
<li>
<p>Most Lisp implementations that compile to C also contain an interpreter that
lets them execute Lisp code on the fly as well. Why?</p>
</li>
</ol>
</div>

<footer>
<a href="the-lox-language.html" class="next">
  Next Chapter: &ldquo;The Lox Language&rdquo; &rarr;
</a>
Robert Nystrom 著  左元 译&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2020</a>
</footer>
</article>

</div>
</body>
</html>
